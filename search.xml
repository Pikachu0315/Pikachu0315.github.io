<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>nodeJs</title>
      <link href="/2022/11/03/nodeJS/nodejs/"/>
      <url>/2022/11/03/nodeJS/nodejs/</url>
      
        <content type="html"><![CDATA[<p>待更新~</p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uniapp</title>
      <link href="/2022/09/25/uniapp/uniapp/"/>
      <url>/2022/09/25/uniapp/uniapp/</url>
      
        <content type="html"><![CDATA[<p>待更新~</p>]]></content>
      
      
      <categories>
          
          <category> uniapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uniapp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序</title>
      <link href="/2022/08/30/%E5%B0%8F%E7%A8%8B%E5%BA%8F/wx%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
      <url>/2022/08/30/%E5%B0%8F%E7%A8%8B%E5%BA%8F/wx%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="浅谈小程序"><a href="#浅谈小程序" class="headerlink" title="浅谈小程序"></a>浅谈小程序</h1><p>在 2016 年的「微信公开课 Pro」演讲中，微信事业群总裁张小龙这样描述了小程序的前景与未来：</p><blockquote><p>“ 小程序是一种不需要下载安装即可使用的应用，它实现了应用 “触手可及” 的梦想，用户扫一扫或者搜一下即可打开应用。也体现了 “用完即走” 的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无须安装卸载 “。</p></blockquote><p>小程序刚发布的时候要求压缩包的体积不能大于 1M，否则无法通过，在 2017 年 4 月做 了改进，由原来的 1M 提升到 2M；</p><p>2017 年 1 月 9 日 0 点，万众瞩目的微信第一批小程序正式低调上线。</p><p>而在 2020 年的「WWDC 苹果全球开发者大会」中，轻应用则被作为 iOS 14 的主要功能进行强调与推介：</p><p><img src="/img/md/wx1.png"></p><blockquote><p>App Clip 就是一种无需用户在 iPhone 或 iPad 上安装完整的应用程序，就可以访问使用该应用程序的部分功能的轻量级应用，它们专注于处理简单快速的任务。</p></blockquote><p>不论是张小龙对「微信小程序」略带文艺的描述，还是在 WWDC 上对于「轻应用」在 iOS 生态中的地位描述，我们都能大抵能理解小程序诞生的初衷。而如果我们把时间从这两场发布会的转至今日，却会发现小程序早已不再局限于「用完即走」与「快速打开」，各式各样的小程序已呈现百花齐放的状态，不论是工具小程序，内容小程序，交易小程序，直播小程序，各种类型应有尽有。</p><p>不妨让我尝试用自己的工作日常举例，早上出门上班，我会打开「天府健康通」扫描地铁场所码，并把健康码给地铁安检查看，临近中午 11 点 30 分，我会用「美团」或「饿了么」为自己订一份工作餐，吃完午饭后我会打开「动物餐厅」看看小猫咪又赚了多少小鱼干，下午会议时使用「腾讯文档」查看会议纪要，快下班的时候用「叮咚买菜」购置晚饭所需的食材，晚上回家做饭时，用「懒饭 App」看看想吃的番茄肥牛饭怎么做。</p><p><img src="/img/md/wx2.png"></p><p>时至今日，当我们说到小程序时，也不仅仅在特指微信小程序，各式各样的平台都纷纷推出了自己专属的小程序平台，不论支付宝、字节跳动、美团还是百度等其他互联网大厂，都纷纷推出了自己专属的小程序平台，且都基于自己的生态业务，为小程序提供流量进行支持，希望用户与开发者能够选择自有平台中的小程序进行开发。</p><p>随着小程序业务的愈演愈烈，越来越多的流量都被引入了互联网巨头的小程序战场中，但在这个过程中，对于战场中「封闭，不透明」的吐槽与争议也逐渐出现，无数企业都希望自己的应用中也能具备运行小程序的能力，希望能够借此抗争小程序被引入寡头所控制的战场，但「知易行难」，快速完成对小程序的底层与容器的研发，所需要花费的精力与时间并不是短时间就能够完成的。</p><p>事实上，小程序可以被理解为是「移动应用 App」的一个细分子集，如果按照「平等透明」的设想，小程序不应该仅仅存在于微信之中，那些我们并不经常使用的应用都可以通过小程序进行重新优化，我们可以通过各式各样的专门应用打开相关的小程序，从而对那些「太重的应用」进行减负操作。</p><p>当然了，小程序还会有这样一些特性需要我们注意：</p><ul><li>小程序不具备「被关注」的能力，获取流量留存用户的操作需要由独立应用或其他渠道完成；</li><li>小程序不具备「推送消息与群发消息」的能力，对用户的信息触达与消息传递的操作需要由其他渠道完成；</li><li>小程序不具备「跨 App 分享 」的能力，因此对于小程序的分享与打开路径，需要在设计产品时提前思考，而不是把鸡蛋放在一个篮子里；</li></ul><h2 id="什么样的应用适合使用小程序开发"><a href="#什么样的应用适合使用小程序开发" class="headerlink" title="什么样的应用适合使用小程序开发"></a>什么样的应用适合使用小程序开发</h2><p>虽然小程序市场时至今日依然是一片蓝海，但我想也不是所有应用「都可以，都应该」使用小程序开发的。</p><p>基于我们的经验与积累来说，符合「逻辑简单，使用低频，对性能要求不极致」的应用场景，更加适合使用小程序进行研发。</p><h3 id="逻辑简单："><a href="#逻辑简单：" class="headerlink" title="逻辑简单："></a>逻辑简单：</h3><p>是指应用的操作逻辑并不十分复杂，各类生活服务（如打车，订餐，查地图与导航等等）都需要给用户提供简单清晰的操作逻辑，而这一类也天然的符合起初小程序「用完即走」的定义，因此十分符合使用小程序研发。一些逻辑复杂的应用场景想要通过小程序进行适配，就可能会面临更多的设计与研发困难，同时在性能和体验也可能会面对更多需要解决的问题。</p><h3 id="使用低频："><a href="#使用低频：" class="headerlink" title="使用低频："></a>使用低频：</h3><p>是指小程序的使用频率不应该太高，比如社交类的钉钉或飞书，金融类的掌上生活或浦大喜奔，媒体类的网易云音乐或斗鱼都不太适合使用小程序进行重新设计。对于用户使用的频率较高的应用来说，直接打开应用进行体验的步骤肯定最快的，此外由于某些行业的特殊性质（比如具备交易，支付等能力）要求，对于安全性与保密性的首选风险判断原则，也不宜使用常见的小程序进行设计。</p><h3 id="对性能要求不极致："><a href="#对性能要求不极致：" class="headerlink" title="对性能要求不极致："></a>对性能要求不极致：</h3><p>是指由于小程序始终存在于某个独立应用（也被称为宿主应用）中，考虑到目前的性能与研发所限制，暂时不太适合开发对于这两者有更高要求的移动应用。比如把原神，王者荣耀这样的游戏应用通过小程序进行重新设计，在目前来说肯定是不现实的。</p><p>当然，随着相关研发实力的增强与产业生态的逐渐补充，也有越来越多的「不可能」变为了「可能」，比如华西证券的「华彩人生」，浦发银行的「浦大喜奔」，某省的移动警务平台等客户都选择使用小程序容器方案进行落地实现</p><h2 id="小程序与-H5，原生应用有何区别？"><a href="#小程序与-H5，原生应用有何区别？" class="headerlink" title="小程序与 H5，原生应用有何区别？"></a>小程序与 H5，原生应用有何区别？</h2><p>很多朋友在了解小程序技术的时候，都会有这样的疑惑“到底与 H5，原生应用”这些技术相比，小程序具有哪些优势与劣势呢？</p><h3 id="H5-移动应用"><a href="#H5-移动应用" class="headerlink" title="H5 移动应用"></a>H5 移动应用</h3><p>我们常说的 H5 其实也通常可以被视为一种 Web App，相比于我们在桌面端浏览器中打开的网页，主要是增加了一些响应式的设计与交互优化，从而使得这些网页更适合在移动端的浏览器中显示运行。既然是网页应用，那依然是基于 JavaScript，CSS 和 HTML 进行实现的，由于是基于各类前端技术栈进行实现，最大的好处就是快速、简单、方便，且有各种技术资料可以参考。</p><p>同样，H5 的缺点与优点也是并存的，比如由于技术已经很成熟了，对于前端经验欠缺的新人来说，面对各式各样的框架，模块、任务管理工具，UI 库可能会出现无从下手的问题；此外相比于原生应用，对于系统权限的获取（比如数据缓存能力，网络通信状态等）都显得比较鸡肋，当低性能的设备加载包含复杂逻辑的页面时，会出现明显的卡顿与延迟问题。</p><h3 id="原生应用"><a href="#原生应用" class="headerlink" title="原生应用"></a>原生应用</h3><p>原生应用也被叫做 Native App，相比于 H5 应用通过前端三大件进行实现不同，原生应用主要会采用 iOS 与 Android 的专有语言 Object-C（或 Swift），Java（或 Kotlin）进行实现，大多我们所常见的国民应用，比如微信，支付宝等都属于这种原生应用。</p><p>既然被叫做「原生应用」，就像操作系统的亲儿子一样，天然在性能与体验上具备优秀的潜质，也有组件库丰富，接口支持完善等各种优势特点。但原生应用最大的缺陷就是不能跨平台研发，以目前的主流市场为例，必须要支持 iOS 与 Android 两个主流平台。</p><h3 id="混合应用"><a href="#混合应用" class="headerlink" title="混合应用"></a>混合应用</h3><p>混合应用一般被称为 Hybrid App。简单来说，混合应用<strong>就是将原生功能封装成对应的 JS 接口，在前端使用 H5 来开发对应的 App （即 H5 作为内容+原生应用作为壳）</strong> ，看上去虽然是一个移动原生应用整体，但实际的页面还是网页，一套代码可以生成 iOS 与 Android 两种安装包，开发成本较低。</p><p>我们常见的淘宝，京东等应用由于更新与优化节奏都十分快速，为了更好的响应「贴近用户」的目标，应用中有的功能通过原生 Native 实现，有的功能则通过 H5 页面进行实现，这种应用就属于我们所说的混合应用。</p><h3 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h3><p>严格意义上来说，小程序并不属于以上 3 种应用的任何一种。小程序主要通过 JavaScript 与 CSS 这种常见的前端技术进行开发，但又没有完全使用 HTML 进行实现，在不同的操作系统中，JavaScript 代码分别运行在 iOS 的 JavaScriptCore 与 Android 的 X5 JSCore 中，各家小程序平台或多或少都有一部分自研的核心，因此渲染视图层的组件也有所不同。</p><p><img src="/img/md/wx3.png"></p><p>相比「 H5 移动应用」与「 移动原生应用」，小程序具备如下优势：</p><ul><li>具备跨平台的能力，一套代码可以在 iOS 与 Android 两个平台中运行；</li><li>远超过 H5 的体验（支持本地缓存，Webview，有丰富的组件与支持库）；</li><li>能获取更多系统权限，完成更加丰富的产品设计；</li><li>可以避免 DOM 泄露（不使用常用的 window 对象与 document 对象）；</li><li>开发简单，上手成本低（比如 FinClip 提供了 FIDE 与开发文档）；</li></ul><h4 id="常见的小程序开发框架有哪些"><a href="#常见的小程序开发框架有哪些" class="headerlink" title="常见的小程序开发框架有哪些"></a>常见的小程序开发框架有哪些</h4><p>以主要的小程序开发框架举例，腾讯云社区的「极乐君」将不同平台下小程序支持的力度整理在一张表中：</p><p><img src="/img/md/wx4.png"></p><h1 id="小程序开发环境"><a href="#小程序开发环境" class="headerlink" title="小程序开发环境"></a>小程序开发环境</h1><p>1、<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">微信文档</a></p><p>2、<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html">微信开发工具下载</a></p><p>3、<a href="https://mp.weixin.qq.com/">注册小程序账号</a></p>]]></content>
      
      
      <categories>
          
          <category> 小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript</title>
      <link href="/2022/08/21/TypeScript/TypeScript/"/>
      <url>/2022/08/21/TypeScript/TypeScript/</url>
      
        <content type="html"><![CDATA[<h1 id="浅谈-JavaScript"><a href="#浅谈-JavaScript" class="headerlink" title="浅谈 JavaScript"></a>浅谈 JavaScript</h1><h3 id="JavaScript-是一门优秀的编程语言吗？"><a href="#JavaScript-是一门优秀的编程语言吗？" class="headerlink" title="JavaScript 是一门优秀的编程语言吗？"></a>JavaScript 是一门优秀的编程语言吗？</h3><p>每个人可能观点并不完全一致，但是从很多角度来看，JavaScript 是一门非常优秀的编程语言；<br>而且，可以说在很长一段时间内这个语言不会被代替，并且会在更多的领域被大家广泛使用；</p><h3 id="著名的-Atwood-定律："><a href="#著名的-Atwood-定律：" class="headerlink" title="著名的 Atwood 定律："></a>著名的 Atwood 定律：</h3><p>Stack Overflow 的创立者之一的 Jeff Atwood 在 2007 年提出了著名的 Atwood 定律。</p><p>any application that can be written in JavaScript, will eventually be written in JavaScript.</p><p>任何可以使用 JavaScript 来实现的应用都最终都会使用 JavaScript 实现。</p><p>其实我们已经看到了，这句话正在一步步被应验：</p><ul><li>Web 端的开发我们一直都是使用 JavaScript；</li><li>移动端开发可以借助于 ReactNative、Weex、Uniapp 等框架实现跨平台开发；</li><li>小程序端的开发也是离不开 JavaScript；</li><li>桌面端应用程序我们可以借助于 Electron 来开发；</li><li>服务器端开发可以借助于 Node 环境使用 JavaScript 来开发。</li></ul><h3 id="JavaScript-的痛点"><a href="#JavaScript-的痛点" class="headerlink" title="JavaScript 的痛点"></a>JavaScript 的痛点</h3><p>并且随着近几年前端领域的快速发展，让 JavaScript 迅速被普及和受广大开发者的喜爱，借助于 JavaScript 本身的 强大，也让使用 JavaScript 开发的人员越来越多。</p><h3 id="优秀的-JavaScript-没有缺点吗？"><a href="#优秀的-JavaScript-没有缺点吗？" class="headerlink" title="优秀的 JavaScript 没有缺点吗？"></a>优秀的 JavaScript 没有缺点吗？</h3><p>其实上由于各种历史因素，JavaScript 语言本身存在很多的缺点；</p><p>比如 ES5 以及之前的使用的 var 关键字关于作用域的问题；</p><p>比如最初 JavaScript 设计的数组类型并不是连续的内存空间；</p><p>比如直到今天 JavaScript 也没有加入类型检测这一机制；</p><h3 id="JavaScript-正在慢慢变好"><a href="#JavaScript-正在慢慢变好" class="headerlink" title="JavaScript 正在慢慢变好"></a>JavaScript 正在慢慢变好</h3><p>不可否认的是，JavaScript 正在慢慢变得越来越好，无论是从底层设计还是应用层面。</p><p>ES6、7、8 等的推出，每次都会让这门语言更加现代、更加安全、更加方便。</p><p>但是知道今天，JavaScript 在类型检测上依然是毫无进展（为什么类型检测如此重要，我后面会聊到）。</p><h3 id="类型带来的问题"><a href="#类型带来的问题" class="headerlink" title="类型带来的问题"></a>类型带来的问题</h3><p>首先你需要知道，编程开发中我们有一个共识：<strong>错误出现的越早越好</strong></p><p>能在<strong>写代码的时候</strong>发现错误，就不要在<strong>代码编译时</strong>再发现（IDE 的优势就是在代码编写过程中帮助我们发现错 误）。</p><p>能在<strong>代码编译期间</strong>发现错误，就不要在<strong>代码运行期间</strong>再发现（类型检测就可以很好的帮助我们做到这一点）。</p><p>能在开发阶段发现错误，就不要在测试期间发现错误，能在测试期间发现错误，就不要在上线后发现错误。</p><p>现在我们想探究的就是如何在 <strong>代码编译期间</strong> 发现代码的错误：</p><p>JavaScript 可以做到吗？不可以，我们来看下面这段经常可能出现的代码问题。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getLength</span>(<span class="params">str</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="property">length</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getLength</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="title function_">getLength</span>()</span><br><span class="line"><span class="comment">// 报错: Uncaught TypeError: Cannot read properties of undefined (reading &#x27;length&#x27;)</span></span><br></pre></td></tr></table></figure><h3 id="这是我们一个非常常见的错误："><a href="#这是我们一个非常常见的错误：" class="headerlink" title="这是我们一个非常常见的错误："></a>这是我们一个非常常见的错误：</h3><p>这个错误很大的原因就是因为 JavaScript 没有对我们传入的参数进行任何的限制，只能等到运行期间才发现这个 错误；<br>并且当这个错误产生时，会影响后续代码的继续执行，也就是整个项目都因为一个小小的错误而深入崩溃；</p><h3 id="当然，你可能会想：我怎么可能犯这样低级的错误呢？"><a href="#当然，你可能会想：我怎么可能犯这样低级的错误呢？" class="headerlink" title="当然，你可能会想：我怎么可能犯这样低级的错误呢？"></a>当然，你可能会想：我怎么可能犯这样低级的错误呢？</h3><p>当我们写像我们上面这样的简单的 demo 时，这样的错误很容易避免，并且当出现错误时，也很容易检查出来；</p><p>但是当我们开发一个大型项目时呢？你能保证自己一定不会出现这样的问题吗？而且如果我们是调用别人的类</p><p>库，又如何知道让我们传入的到底是什么样的参数呢？</p><p>但是，如果我们可以给 JavaScript 加上很多限制，在开发中就可以很好的避免这样的问题了：</p><p>比如我们的 getLength 函数中 str 是一个必传的类型，没有调用者没有传编译期间就会报错；</p><p>比如我们要求它的必须是一个 String 类型，传入其他类型就直接报错；</p><p>那么就可以知道很多的错误问题在编译期间就被发现，而不是等到运行时再去发现和修改；</p><h3 id="类型思维的缺失"><a href="#类型思维的缺失" class="headerlink" title="类型思维的缺失"></a>类型思维的缺失</h3><p>我们已经简单体会到没有类型检查带来的一些问题，JavaScript 因为从设计之初就没有考虑类型的约束问题，所以</p><p>造成了前端开发人员关于<strong>类型思维的缺失：</strong></p><p><strong>前端开发人员</strong>通常不关心变量或者参数是什么类型的，如果在必须确定类型时，我们往往需要使用各种判断验 证；</p><p>从其他方向转到前端的人员，也会因为没有类型约束，而总是担心自己的代码不安全，不够健壮；</p><p>所以我们经常会说 JavaScript<strong>不适合开发大型项目</strong>，因为当项目一旦庞大起来，这种宽松的类型约束会带来非常多 的安全隐患，多人员开发它们之间也没有<strong>良好的类型契约</strong>。</p><p>比如当我们去实现一个核心类库时，如果没有类型约束，那么需要对别人传入的参数进行各种验证来保证我们 代码的健壮性；</p><p>比如我们去调用别人的函数，对方没有对函数进行任何的注释，我们只能去看里面的逻辑来理解这个函数需要 传入什么参数，返回值是什么类型；</p><h3 id="为-JavaScript-添加类型约束的好处"><a href="#为-JavaScript-添加类型约束的好处" class="headerlink" title="为 JavaScript 添加类型约束的好处"></a>为 JavaScript 添加类型约束的好处</h3><p>背景：JS 的类型系统存在“先天缺陷“，代码中绝大部分错误都是类型错误(Uncaught TypeError )。<br>问题 ∶ 增加了找 Bug、改 Bug 的时间，严重影响开发效率。</p><p>从编程语言的动静来区分</p><p>TypeScript 属于静态类型的编程语言，JS 属于动态类型的编程语言</p><p>静态类型︰编译期做类型检查；动态类型 ∶ 执行期做类型检查。</p><p>代码编译和代码执行的顺序 ∶1 编译，2 执行。</p><p>对于 JS 来说 ∶ 需要等到代码真正去执行的时候才能发现错误（晚）。</p><p>对于 TS 来说 ∶ 在代码编译的时候（代码执行前）就可以发现错误（早）。</p><p>并且，配合 VSCode 等开发工具，TS 可以提前到在编写代码的同时就发现代码中的错误，减少找 bug、改 bug 时间</p><h2 id="Ts-相比-Js-的优势"><a href="#Ts-相比-Js-的优势" class="headerlink" title="Ts 相比 Js 的优势"></a>Ts 相比 Js 的优势</h2><ul><li>更早（写代码的同时）发现错误，减少找 Bug、改 Bug 时间，提升开发效率。</li><li>程序中任何位置的代码都有代码提示，随时随地的安全感，增强了开发体验。</li><li>强大的类型系统提升了代码的可维护性，使得重构代码更加容易。</li><li>支持最新的 ECMAScript 语法，优先体验最新的语法，让你走在前端技术的最前沿。</li><li>TS 类型推断机制，不需要在代码中的每个地方都显示标注类型，让你在享受优势的同时，尽量降低了成本。</li><li>除此之外，Vue 3 源码使用 TS 重写、Angular 默认支持 TS、React 与 TS 完美配合，TypeScript 已成为大中型前端项目的首选编程语言</li></ul><h3 id="为了弥补-JavaScript-类型约束上的缺陷，增加类型约束，很多公司推出了自己的方案："><a href="#为了弥补-JavaScript-类型约束上的缺陷，增加类型约束，很多公司推出了自己的方案：" class="headerlink" title="为了弥补 JavaScript 类型约束上的缺陷，增加类型约束，很多公司推出了自己的方案："></a>为了弥补 JavaScript 类型约束上的缺陷，增加类型约束，很多公司推出了自己的方案：</h3><p>2014 年，Facebook 推出了 flow 来对 JavaScript 进行类型检查；</p><p>同年，Microsoft 微软也推出了 TypeScript1.0 版本；</p><p>他们都致力于为 JavaScript 提供类型检查；</p><p>而现在，<strong>无疑 TypeScript 已经完全胜出</strong>：</p><p>Vue2.x 的时候采用的就是 flow 来做类型检查；</p><p>Vue3.x 已经全线转向 TypeScript，98.3%使用 TypeScript 进行了重构；</p><p>而 Angular 在很早期就使用 TypeScript 进行了项目重构并且需要使用 TypeScript 来进行开发；</p><p>而甚至 Facebook 公司一些自己的产品也在使用 TypeScript；</p><p>学习 TypeScript 不仅仅可以为我们的代码增加类型约束，而且可以培养我们前端程序员具备类型思维。</p><h1 id="TypeScript-介绍"><a href="#TypeScript-介绍" class="headerlink" title="TypeScript 介绍"></a>TypeScript 介绍</h1><p><img src="/img/md/tsjieshao.png" alt="👇👇👇高质量精短介绍"><br>虽然我们已经知道 TypeScript 是干什么的了，也知道它解决了什么样的问题，但是我们还是需要全面的来认识一下 TypeScript 到底是什么？</p><h2 id="我们来看一下-TypeScript-在-GitHub-和官方上对自己的定义："><a href="#我们来看一下-TypeScript-在-GitHub-和官方上对自己的定义：" class="headerlink" title="我们来看一下 TypeScript 在 GitHub 和官方上对自己的定义："></a>我们来看一下 TypeScript 在 GitHub 和官方上对自己的定义：</h2><p>GitHub 说法：TypeScript is a superset of JavaScript that compiles to clean JavaScript output.</p><p>TypeScript 官网：TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.</p><p>翻译一下：TypeScript 是拥有类型的 JavaScript 超集，它可以编译成普通、干净、完整的 JavaScript 代码。</p><p>怎么理解上面的话呢？</p><p>我们可以将 TypeScript 理解成加强版的 JavaScript。</p><p>JavaScript 所拥有的特性，TypeScript 全部都是支持的，并且它紧随 ECMAScript 的标准，所以 ES6、ES7、ES8 等新语法标准，它都是 支持的；</p><p>并且在语言层面上，不仅仅增加了类型约束，而且包括一些语法的扩展，比如枚举类型（Enum）、元组类型（Tuple）等；</p><p>TypeScript 在实现新特性的同时，总是保持和 ES 标准的同步甚至是领先；</p><p>并且 TypeScript 最终会被编译成 JavaScript 代码，所以你并不需要担心它的兼容性问题，在编译时也不需要借助于 Babel 这样的工具；</p><p>所以，我们可以把 TypeScript 理解成更加强大的 JavaScript，不仅让 JavaScript 更加安全，而且给它带来了诸多好用的好用特性；</p><h1 id="TS-初体验"><a href="#TS-初体验" class="headerlink" title="TS 初体验"></a>TS 初体验</h1><h2 id="Ts-的编译环境"><a href="#Ts-的编译环境" class="headerlink" title="Ts 的编译环境"></a>Ts 的编译环境</h2><p>在前面我们提到过，TypeScript 最终会被编译成 JavaScript 来运行，所以我们需要搭建对应的环境：</p><p>我们需要在电脑上安装 TypeScript，这样就可以通过 TypeScript 的 Compiler 将其编译成 JavaScript；</p><p><img src="/img/md/ts2.png" alt="👇👇👇高质量精短介绍"><br>所以，我们需要全局安装</p><h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><p>npm install typescript -g</p><h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h3><p>tsc –version</p><h2 id="TS-的运行环境"><a href="#TS-的运行环境" class="headerlink" title="TS 的运行环境"></a>TS 的运行环境</h2><p>如果我们每次为了查看 TypeScript 代码的运行效果，都通过经过两个步骤的话就太繁琐了：</p><p>第一步：通过 tsc 编译 TypeScript 到 JavaScript 代码；</p><p>第二步：在浏览器或者 Node 环境下运行 JavaScript 代码；</p><p>是否可以简化这样的步骤呢？</p><p>比如编写了 TypeScript 之后可以直接运行在浏览器上？</p><p>比如编写了 TypeScript 之后，直接通过 node 的命令来执行？</p><p>上面我提到的两种方式，可以通过两个解决方案来完成：</p><h3 id="方式一：通过-webpack，配置本地的-TypeScript-编译环境和开启一个本地服务，可以直接运行在浏览器上；"><a href="#方式一：通过-webpack，配置本地的-TypeScript-编译环境和开启一个本地服务，可以直接运行在浏览器上；" class="headerlink" title="方式一：通过 webpack，配置本地的 TypeScript 编译环境和开启一个本地服务，可以直接运行在浏览器上；"></a>方式一：通过 webpack，配置本地的 TypeScript 编译环境和开启一个本地服务，可以直接运行在浏览器上；</h3><ul><li>npm init –y</li><li>npm i webpack webpack-cli –D</li><li>npm i ts-loader typescript –D</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.ts&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&#x27;.tsx&#x27;</span>,<span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/.ts$/</span>,</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;ts-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其它配置项参考webpack章节 ~</span><br></pre></td></tr></table></figure><h3 id="方式二：通过-ts-node-库，为-TypeScript-的运行提供执行环境；"><a href="#方式二：通过-ts-node-库，为-TypeScript-的运行提供执行环境；" class="headerlink" title="方式二：通过 ts-node 库，为 TypeScript 的运行提供执行环境；"></a>方式二：通过 ts-node 库，为 TypeScript 的运行提供执行环境；</h3><p>安装 npm install -g ts-node</p><p>另外 ts-node 需要依赖 tslib 和 @types&#x2F;node 两个包：</p><p>npm install tslib @types&#x2F;node -g</p><p>现在，我们可以直接通过 ts-node 来运行 TypeScript 的代码：</p><p>ts-node index.ts</p><p>注意：ts-node 7.0.0 以上就不自动识别 tsconfig.json 了，得加上 –files 才能识别</p><p>ts-node index.ts –files</p>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack</title>
      <link href="/2022/07/17/webpack/webpack/"/>
      <url>/2022/07/17/webpack/webpack/</url>
      
        <content type="html"><![CDATA[<h1 id="npm-相关"><a href="#npm-相关" class="headerlink" title="npm 相关"></a>npm 相关</h1><p><strong>临时记录，后续单独开篇 ~</strong></p><p>在我们需要下载第三方包之前 需要先初始化项目</p><p><strong>npm init -y</strong>: 初始化项目, 生成 package.json 文件</p><p><strong>init</strong> 表示的是初始化</p><p><strong>-y</strong> 表示的是所有需要填写的内容都使用默认的</p><h2 id="package-json-字段"><a href="#package-json-字段" class="headerlink" title="package.json 字段"></a>package.json 字段</h2><p>ame：包名。规范定义它需要由小写的字母和数字组成，可以包含.、_和-，但不允许出现空格。不允许出现中文，<strong>包名必须是唯一的</strong>，以免对外公布时产生重名冲突的误解。除此之外，NPM 还建议不要在包名中附带上 node 或 js 来重复标识它是 JavaScript 或 Node 模块。</p><ul><li>author：作者</li><li>description：包的简介</li><li>version：版本号</li><li>main：入口文件</li><li>keywords：关键词数组，NPM 中主要用来做分类搜索。一个好的关键词数组有利于用户快速找到你编写的包。</li><li>devDependencies：一些模块只在开发时需要依赖。配置这个属性，可以提示包的后续开发者安装依赖包。</li><li>dependencies：使用当前包所需要依赖的包列表。这个属性十分重要，NPM 会通过这个属性帮助自动加载依赖的包。</li><li>scripts：脚本说明对象。它主要被包管理器用来安装、编译、测试和卸载包。</li><li>bin：一些包作者希望包可以作为命令行工具使用。配置好 bin 字段后，通过 npm install package name -g 命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行。前面的 node -gyp 即是这样安装的。通过-g 命令安装的模块包称为全局模式。</li></ul><h2 id="dependencies-VS-devDependencies"><a href="#dependencies-VS-devDependencies" class="headerlink" title="dependencies VS devDependencies"></a>dependencies VS devDependencies</h2><p>dependencies：生产依赖 项目在部署运行时需要用到的依赖</p><p>(npm i 包名 –save 或者 npm i 包名)</p><p>devDependencies：开发依赖 项目在开发时候需要用到的依赖</p><p>(npm i 包名 –save-dev 或者 npm i 包名 -D)</p><p>还有一种 npm i 包名 –g：全局安装 &#x3D;&gt; 安装在 nodejs 目录下的 node_modules 中</p><p>安装在全局的目的是为了在任意位置都能够使用该包</p><p>为什么能在任意位置使用它呢？因为配置了环境变量</p><p>初始化项目后可以通过 npm i（install） 包名，比如：npm i jquery</p><p>来下载第三方模块，第三方模块会默认下载到当前项目下的 node_modules 中</p><p>卸载第三方包：npm un（uninstall） 包名（后缀和安装包的时候保持一致）</p><p>npm 设置淘宝镜像源：<strong>npm config set registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org/</a></strong></p><h1 id="什么是构建工具"><a href="#什么是构建工具" class="headerlink" title="什么是构建工具"></a>什么是构建工具</h1><p><strong>事实上随着前端的快速发展，目前前端的开发已经变的越来越复杂了：</strong><br>比如开发过程中我们需要通过模块化的方式来开发；</p><p>比如也会使用一些高级的特性来加快我们的开发效率或者安全性，比如通过 ES6+、TypeScript 开发脚本逻辑， 通过 sass、less 等方式来编写 css 样式代码；</p><p>比如开发过程中，我们还希望实时的监听文件的变化来并且反映到浏览器上，提高开发的效率；</p><p>比如开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化；</p><p>等等….</p><p>上述这些工作理论上是可以人工完成的，但是它繁琐，工作量大，本质是无意义的劳动，人为的错误也随着流程的增加而增加了更多的出错率。所以每一个团队都希望有一种工具，能帮助整个团队在开发中能精简流程、提高效率、减少错误率，管理各种小工具之间的错综复杂的关系或者配置，这种工具就叫构建工具。</p><p>说到构建工具，我往往会在前面加<strong>「自动化」</strong>三个字，因为构建工具就是用来让我们不再做机械重复的事情，解放我们的双手的(my god)。所以构建工具作用是：提升项目性能，提高开发效率。</p><h1 id="构建工具的发展"><a href="#构建工具的发展" class="headerlink" title="构建工具的发展"></a>构建工具的发展</h1><p>有了工具能满足基本的打包工作，对于开发人员而言总是需要更精益求精。就像在一辆能发动的车上去安装各种零件来提升使用者的体验。这些零件就是构建工具所需要的插件，这些插件对提升开发效率很有帮助，包括语法转换（Babel），模板热更新（HotModuleReplacementPlugin），清理重复的打包的文件（clean-webpack-plugin）等等。</p><p>构建工具目前来说还在处于不停发展的阶段，但是相应的打包技术已经很成熟。 本次主要介绍市面上比较火热的 Gulp，Grunt， Webpack, Vite 这三个打包工具之间的对比和它们的优势。</p><h1 id="构建工具介绍"><a href="#构建工具介绍" class="headerlink" title="构建工具介绍"></a>构建工具介绍</h1><p>Grunt: 是一个优化前端的开发流程的工具。<br>配置一系列的 task，定义 task 处理的事务（例如文件压缩合并、启动 server、版本控制等），然后定义执行顺序，来让 Grunt 执行这些 task，从而构建项目的整个前端开发流程。</p><p>工作方式:<br><img src="/img/md/webpack1.png"></p><p>Wepack: 是一种模块化的解决方案。更强调模块化。<br>把你的项目当做一个整体，通过一个指定的主文件名（index.js, 一般是入口文件），webpack 将从这个文件开始找到你的项目所依赖的文件，使用 loaders 来处理它们，最后打包为一个浏览器可识别的 js 文件。<br><img src="/img/md/webpack2.png"></p><p>Vite: 一种新型前端构建工具,它区别与不同的打包工具,它在开发环境中不对项目进行整体打包。<br>原因：当我们的构建的项目越来越庞大时，对整个项目进行资源整合的时间会变长，如果有数千个模块的项目在进行构建时甚至需要几分钟才能启动开发服务器。所以 vite 解决了在开发过程中需要等待整个项目打包这一段过程，让开发时更加丝滑。<br>依赖：使用 esbuild（GO 编写）预构建依赖，比 JavaScript 编写的打包器预构建依赖快 10-100 倍。<br>源码：在浏览器请求资源时-&gt; vite 转换一些非 js 文件-&gt;动态导入代码。<br>源码利用浏览器的协商缓存（304 Not Modified），依赖模块请求则会通过 Cache-Control: max-age&#x3D;31536000, immutable 进行强缓存，保持热更新的速度。<br><img src="/img/md/webpack3.png"></p><h1 id="如何选择适合的构建工具？"><a href="#如何选择适合的构建工具？" class="headerlink" title="如何选择适合的构建工具？"></a>如何选择适合的构建工具？</h1><p>Grunt 对于一些中小型项目而言更加轻便和灵活，如果只针对代码压缩合并，Grunt 就可以满足要求，发展历程长，基本是稳定的。但是如果要处理庞大的项目文件，特别是处理多种类型的资源文件，强调模块开发，Webpack 则更适合这个场景。Webpack 对于中大型项目而言是更加稳定的，文档资料和迭代速度也很快。当然这对开发人员而言也是挺头疼的，隔一段时间就需要去适应文档的配置。Vite 作为一门新的构建技术，想要它去构建一门稳定的中大型项目有点冒险，虽然已经发布稳定版本，但是还是会有一些潜在的风险，等它更多人推广后使用更加稳妥，但是对于平时构建一些个人网站和项目等使用 vite，感受一下它的便捷也可以。</p><h1 id="什么是-webpack"><a href="#什么是-webpack" class="headerlink" title="什么是 webpack"></a>什么是 webpack</h1><p><strong>webpack 是一种前端资源构建工具，一个静态模块打包器(module bundler)。 在 webpack 看来,前端的所有资源文件(js&#x2F;json&#x2F;css&#x2F;img&#x2F;less&#x2F;…)都会作为模块处理。 它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle)。</strong></p><p><img src="/img/md/webpack4.png"></p><h1 id="理解-module、chunk、bundle"><a href="#理解-module、chunk、bundle" class="headerlink" title="理解 module、chunk、bundle"></a>理解 module、chunk、bundle</h1><p>在 webpack 中，一切皆 module，任何一个文件都可以看成是 module。js、css、图片等都是 module<br>webpack 会将入口文件以及它的依赖引入到一个 chunk 中，然后进过一系列处理打包成 bundle</p><p><img src="/img/md/webpack5.png"></p><p>大致流程如下：</p><p>1、根据 index.js 入口文件依赖关系生成树状图</p><p>2、根据树状图引入相关的资源 生成 chunk(块)</p><p>3、对 chunk 进行处理 (babel、less-loader …)</p><p>4、打包生成 bundler.js</p><p>5、将 bundler.js 文件引入到 index.html 中</p><h1 id="webpack-五个核心概念"><a href="#webpack-五个核心概念" class="headerlink" title="webpack 五个核心概念"></a>webpack 五个核心概念</h1><h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><p><strong>入口（Entry）：指示 webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图。其取值可以是字符串，数组或者一个对象</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单入口单文件</span></span><br><span class="line"><span class="attr">entry</span>: <span class="string">&quot;./src/index.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单入口多文件</span></span><br><span class="line"><span class="attr">entry</span>: [<span class="string">&quot;./ src/index.js&quot;</span>, <span class="string">&quot;./src/common.js&quot;</span>] <span class="comment">// 若index.js与common.js没有依赖关系，可以通过此方式将它们打包在一起</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多入口</span></span><br><span class="line"><span class="attr">entry</span>: &#123;</span><br><span class="line">  <span class="attr">page1</span>: <span class="string">&quot;./src/page1.js&quot;</span>,</span><br><span class="line">  <span class="attr">page2</span>: <span class="string">&quot;./src/page2.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p><strong>输出（Output）：指示 webpack 打包后的资源 bundles 输出到哪里去，以及如何命名</strong></p><p>webpack 打包的输出，常用配置如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">  <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;./dist&quot;</span>),</span><br><span class="line">  <span class="comment">// 单入口时（默认）</span></span><br><span class="line">  <span class="comment">// filename: &quot;main.js&quot;,</span></span><br><span class="line">  <span class="comment">// filename: &quot;js/main.js&quot;, // filename也可以写路径，表示输出到 dist/js 目录下</span></span><br><span class="line">  <span class="comment">// 多入口时，由于会有多个输出，因此文件名不能写死</span></span><br><span class="line">  <span class="attr">filename</span>: <span class="string">&quot;[name].js&quot;</span>, <span class="comment">// name表示chunk的名称，此处为entry中的key值</span></span><br><span class="line">  <span class="attr">chunkFilename</span>: <span class="string">&quot;[name].js&quot;</span>, <span class="comment">// 按需加载的模块打包后的名称</span></span><br><span class="line">  <span class="attr">publicPath</span>: <span class="string">&quot;/&quot;</span> <span class="comment">// 项目部署在服务器上的路径，如果在根路径则为 /</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p><strong>处理器（Loader）：webpack 默认只能处理 js、json 格式的文件，而 loader 的作用则是将其他格式的文件，转换成 webpack 能够处理的文件</strong></p><p>使用 loader 需要在 webpack 配置文件的 module.rules 中配置：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"> <span class="attr">entry</span>: ...,</span><br><span class="line"> <span class="attr">output</span>: ...,</span><br><span class="line"> <span class="attr">module</span>: &#123;</span><br><span class="line">   <span class="attr">noParse</span>:  <span class="regexp">/node_modules/</span>, <span class="comment">//忽略解析 node_modules 中的文件</span></span><br><span class="line">   <span class="attr">rules</span>: [</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="attr">test</span>: <span class="regexp">/\.xxx$/</span>, <span class="comment">// 匹配后缀名为xxx的文件</span></span><br><span class="line">       <span class="comment">// 单个loader</span></span><br><span class="line">       <span class="comment">// loader: &quot;xxx-loader&quot;,</span></span><br><span class="line">       <span class="comment">// options: &#123;&#125;,</span></span><br><span class="line">       <span class="comment">// 多个loader，loader的处理顺序为从后往前，因此需要优先处理的loader放在数组最后面</span></span><br><span class="line">       <span class="comment">// use: [&quot;xxxx-loader&quot;, &quot;xxx-loader&quot;],</span></span><br><span class="line">       <span class="comment">//  如果某个loader需要配置，写成下面的格式</span></span><br><span class="line">       <span class="attr">use</span>: [</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="attr">loader</span>: <span class="string">&quot;xxxx-loader&quot;</span>,</span><br><span class="line">           <span class="attr">options</span>: &#123;&#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="string">&quot;xxx-loader&quot;</span></span><br><span class="line">       ],</span><br><span class="line">       <span class="attr">include</span>: [path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;./src&quot;</span>)], <span class="comment">// 只解析src中的文件，可以是正则</span></span><br><span class="line">       <span class="attr">exclude</span>: [path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;./library&quot;</span>)], <span class="comment">// 忽略library中的文件，可以是正则</span></span><br><span class="line">       <span class="comment">// 当多个规则同时匹配某类文件时，可以使用enforce参数指定优先级</span></span><br><span class="line">       <span class="attr">enforce</span>: <span class="string">&quot;pre&quot;</span> <span class="comment">// 优先执行该规则里的loader，post 最后执行该规则里的loader</span></span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="comment">// 当规则匹配时，不再匹配后面的规则。例如某个文件匹配到了第一个规则，不再匹配后面规则</span></span><br><span class="line">       <span class="attr">oneOf</span>: [</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="attr">test</span>: <span class="regexp">/\.xxx$/</span>,</span><br><span class="line">           <span class="attr">use</span>: <span class="string">&quot;xxx-loader&quot;</span></span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="attr">test</span>: <span class="regexp">/\.xxx$/</span>,</span><br><span class="line">           <span class="attr">use</span>: <span class="string">&quot;xxx-loader&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">       ]</span><br><span class="line">     &#125;</span><br><span class="line">   ]</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p><strong>插件(Plugins)可以用于执行范围更广的任务，它能处理 loader 无法处理的事情。插件的范围包括，从打包优化和压缩， 一直到重新定义环境中的变量等。</strong></p><p>它使用非常简单，在 plugins 数组中添加插件的实例化对象即可</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xxxWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;xxx-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: ...,</span><br><span class="line">  <span class="attr">output</span>: ...,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title function_">xxxWebpackPlugin</span>(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title function_">xxxxWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 插件的配置项</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><p><strong>webpack 打包分为两种模式，开发模式（development）与生产模式（production），默认为生产模式</strong></p><table><thead><tr><th align="left">选择</th><th align="left">描述</th><th align="left">特点</th></tr></thead><tbody><tr><td align="left">development</td><td align="left">会将 process.env.NODE_ENV 的值设为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin。</td><td align="left">能让代码本地调试 运行的环境</td></tr><tr><td align="left">production</td><td align="left">会将 process.env.NODE_ENV 的值设为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin.</td><td align="left">能让代码优化上线 运行的环境</td></tr></tbody></table><p><strong>Mode 的配置更多含义</strong></p><p><img src="/img/md/webpack6.png"><br><img src="/img/md/webpack7.png"></p><h1 id="webpack-使用前提"><a href="#webpack-使用前提" class="headerlink" title="webpack 使用前提"></a>webpack 使用前提</h1><p>webpack 的官方文档是 <a href="https://webpack.js.org/">https://webpack.js.org/</a></p><p>webpack 的中文官方文档是 <a href="https://webpack.docschina.org/">https://webpack.docschina.org/</a></p><p>DOCUMENTATION：文档详情，也是我们最关注的</p><p>Webpack 的运行是依赖 Node 环境的，所以我们电脑上必须有 Node 环境</p><p>所以我们需要先安装 Node.js，并且同时会安装 npm；</p><p>我当前电脑上的 node 版本是 v14.15.5，npm 版本是 6.14.11（你也可以使用 nvm 或者 n 来管理 Node 版本）；</p><p>Node 官方网站：<a href="https://nodejs.org/">https://nodejs.org/</a></p><p><img src="/img/md/webpack8.png"></p><h1 id="webpack-安装"><a href="#webpack-安装" class="headerlink" title="webpack 安装"></a>webpack 安装</h1><p><strong>webpack 的安装目前分为两个：webpack、webpack-cli</strong></p><h2 id="那么它们是什么关系呢？"><a href="#那么它们是什么关系呢？" class="headerlink" title="那么它们是什么关系呢？"></a>那么它们是什么关系呢？</h2><p>执行 webpack 命令，会执行 node_modules 下的.bin 目录下的 webpack；</p><p>webpack 在执行时是依赖 webpack-cli 的，如果没有安装就会报错；</p><p>而 webpack-cli 中代码执行时，才是真正利用 webpack 进行编译和打包的过程；</p><p>所以在安装 webpack 时，我们需要同时安装 webpack-cli（第三方的脚手架事实上是没有使用 webpack-cli 的，而是类似于自 己的 vue-service-cli 的东西）</p><p><img src="/img/md/webpack9.png"></p><p>全局安装：<strong>npm install webpack webpack-cli –g</strong></p><p>局部安装：<strong>npm install webpack webpack-cli –D</strong></p><h1 id="webpack-的默认打包"><a href="#webpack-的默认打包" class="headerlink" title="webpack 的默认打包"></a>webpack 的默认打包</h1><p>我们可以通过 webpack 进行打包，之后运行打包之后的代码</p><p>在目录下直接执行 webpack 命令：<strong>webpack</strong></p><p>生成一个 dist 文件夹，里面存放一个 main.js 的文件，就是我们打包之后的文件：</p><p>这个文件中的代码被压缩和丑化了；</p><p>另外我们发现代码中依然存在 ES6 的语法，比如箭头函数、const 等，这是因为默认情况下 webpack 并不清楚我们打包后的文 件是否需要转成 ES5 之前的语法，后续我们需要通过 babel 来进行转换和设置；</p><p>我们发现是可以正常进行打包的，但是有一个问题，webpack 是如何确定我们的入口的呢？</p><p>事实上，当我们运行 webpack 时，webpack 会查找当前目录下的 src&#x2F;index.js 作为入口；</p><p>所以，如果当前项目中没有存在 src&#x2F;index.js 文件，那么会报错；</p><p>当然，我们也可以通过配置来指定入口和出口</p><h2 id="开发环境指令："><a href="#开发环境指令：" class="headerlink" title="开发环境指令："></a>开发环境指令：</h2><p><strong>webpack src&#x2F;js&#x2F;index.js -o build&#x2F;js&#x2F;built.js –mode&#x3D;development</strong></p><p>功能：webpack 能够编译打包 js 和 json 文件，并且能将 es6 的模块化语法转换成 浏览器能识别的语法。</p><p><strong>webpack –entry .&#x2F;src&#x2F;main.js –output-path .&#x2F;build&#x2F;js&#x2F;bundle.js –mode&#x3D;development</strong></p><h2 id="生产环境指令："><a href="#生产环境指令：" class="headerlink" title="生产环境指令："></a>生产环境指令：</h2><p><strong>webpack src&#x2F;js&#x2F;index.js -o build&#x2F;js&#x2F;built.js –mode&#x3D;production</strong></p><p>功能：在开发配置功能上多一个功能，压缩代码。</p><p><strong>webpack –entry .&#x2F;src&#x2F;main.js –output-path .&#x2F;build&#x2F;js&#x2F;bundle.js –mode&#x3D;production</strong></p><h2 id="配置-script-脚本"><a href="#配置-script-脚本" class="headerlink" title="配置 script 脚本"></a>配置 script 脚本</h2><p>在 package.json，script 字段下配置脚本，执行命令更为简便：npm run 脚本名</p><p>结论 ：</p><ul><li>webpack 能够编译打包 js 和 json 文件。</li><li>能将 es6 的模块化语法转换成浏览器能识别的语法。</li><li>能压缩代码。</li></ul><p>问题 ：</p><ul><li>不能编译打包 css、img 等文件。</li><li>不能将 js 的 es6 基本语法转化为 es5 以下语法。</li><li>在通常情况下，webpack 需要打包的项目是非常复杂的，并且我们需要一系列的配置来满足要求，默认配置必然是不可以的。</li></ul><h1 id="webpack-开发环境配置"><a href="#webpack-开发环境配置" class="headerlink" title="webpack 开发环境配置"></a>webpack 开发环境配置</h1><h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><p>在项目根目录下创建文件 webpack.config.js，来作为 webpack 的配置文件，名字默认，如果要修改，执行时需要添加 –config 配置文件名来读取该配置文件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>); <span class="comment">// node 内置核心模块，用来处理路径问题</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/js/index.js&quot;</span>, <span class="comment">// 入口文件</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// 输出配置</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;./bundle.js&quot;</span>, <span class="comment">// 输出文件名</span></span><br><span class="line">    <span class="attr">path</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&quot;build/js&quot;</span>), <span class="comment">// 输出文件路径配置</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>, <span class="comment">//开发环境</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="打包样式资源"><a href="#打包样式资源" class="headerlink" title="打包样式资源"></a>打包样式资源</h2><h3 id="1、准备-css、less-资源"><a href="#1、准备-css、less-资源" class="headerlink" title="1、准备 css、less 资源"></a>1、准备 css、less 资源</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个元素</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">div.<span class="property">className</span> = <span class="string">&#x27;dv&#x27;</span></span><br><span class="line">div.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;100px&#x27;</span></span><br><span class="line">div.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&#x27;100px&#x27;</span></span><br><span class="line">div.<span class="property">innerHTML</span> = <span class="string">&#x27;把酒祝东风，且共从容&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div)</span><br><span class="line"></span><br><span class="line">.<span class="property">dv</span> &#123;</span><br><span class="line">  background-<span class="attr">color</span>:tomato;</span><br><span class="line">  <span class="comment">/* 页面文字不让选中 */</span></span><br><span class="line">  user-<span class="attr">select</span>: none;</span><br><span class="line">&#125;</span><br><span class="line">执行编译发现报错: 模块解析失败，你需要一个合适的loader来处理这个文件类型</span><br><span class="line"></span><br><span class="line">上面的错误信息告诉我们需要一个loader来加载这个css文件，但是loader是什么呢？</span><br><span class="line">loader 可以用于对模块的源代码进行转换；</span><br><span class="line">我们可以将css文件也看成是一个模块，我们是通过<span class="keyword">import</span>来加载这个模块的；</span><br><span class="line">在加载这个模块时，webpack其实并不知道如何对其进行加载，我们必须制定对应的loader来完成这个功能；</span><br><span class="line">那么我们需要一个什么样的loader呢？</span><br><span class="line">对于加载css文件来说，我们需要一个可以读取css文件的loader；</span><br><span class="line">这个loader最常用的是css-loader</span><br></pre></td></tr></table></figure><h3 id="2、下载安装-loader-包-npm-i-css-loader-D"><a href="#2、下载安装-loader-包-npm-i-css-loader-D" class="headerlink" title="2、下载安装 loader 包 npm i css-loader -D"></a>2、下载安装 loader 包 npm i css-loader -D</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">如何使用这个loader来加载css文件呢？有三种方式：</span><br><span class="line">- 内联方式；</span><br><span class="line">- <span class="variable constant_">CLI</span>方式（webpack5中不再使用）；</span><br><span class="line">- 配置方式；</span><br><span class="line">内联方式：内联方式使用较少，因为不方便管理；</span><br><span class="line">- 在引入的样式前加上使用的loader，并且使用!分割: <span class="keyword">import</span> <span class="string">&#x27;css-loader!./js/a.css&#x27;</span></span><br><span class="line"><span class="variable constant_">CLI</span>方式（webpack5中不再使用）这里不展开说</span><br></pre></td></tr></table></figure><h3 id="3、修改配置文件"><a href="#3、修改配置文件" class="headerlink" title="3、修改配置文件"></a>3、修改配置文件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// resolve 用来拼接绝对路径的方法</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// webpack 配置</span></span><br><span class="line">  <span class="comment">// 入口起点</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">  <span class="comment">// 输出</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// 输出文件名</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;built.js&quot;</span>,</span><br><span class="line">    <span class="comment">// 输出路径</span></span><br><span class="line">    <span class="comment">// __dirname nodejs 的变量，代表当前文件的目录绝对路径</span></span><br><span class="line">    <span class="attr">path</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// loader 的配置</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="comment">// module.rules中允许我们配置多个loader（因为我们也会继续使用其他的loader，来完成其他文件的加载）</span></span><br><span class="line">    <span class="comment">// 这种方式可以更好的表示loader的配置，也方便后期的维护，同时也让你对各个Loader有一个全局的概览</span></span><br><span class="line">    <span class="comment">// rules属性对应的值是一个数组 数组中存放的是一个个的Rule，Rule是一个对象，对象中可以设置多个属性</span></span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// 详细 loader 配置</span></span><br><span class="line">      <span class="comment">// 不同文件必须配置不同 loader 处理</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用于对 resource（资源）进行匹配的，通常会设置成正则表达式</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// 对应的值时一个数组 表示使用哪些 loader 进行处理</span></span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          <span class="comment">// use 数组中 loader 执行顺序：从右到左，从下到上 依次执行</span></span><br><span class="line">          <span class="comment">// 创建 style 标签，将 js 中的样式资源插入进行，添加到 head 中生效</span></span><br><span class="line">          <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">          <span class="comment">// 将 css 文件变成 commonjs 模块加载 js 中，里面内容是样式字符串</span></span><br><span class="line">          <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">// use属性：对应的值时一个数组：[UseEntry]</span></span><br><span class="line">        <span class="comment">// UseEntry是一个对象，可以通过对象的属性来设置一些其他属性</span></span><br><span class="line">        <span class="comment">// loader：必须有一个 loader属性，对应的值是一个字符串；</span></span><br><span class="line">        <span class="comment">// options：可选的属性，值是一个字符串或者对象，值会被传入到loader中；</span></span><br><span class="line">        <span class="comment">// query：目前已经使用options来替代；</span></span><br><span class="line">        <span class="comment">// 传递字符串（如：use: [ &#x27;style-loader&#x27; ]）是 loader 属性的简写方式（如：use: [ &#123; loader: &#x27;style-loader&#x27;&#125; ]）；</span></span><br><span class="line">        <span class="comment">// loader属性： Rule.use: [ &#123; loader &#125; ] 的简写。</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 模式</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>, <span class="comment">// 开发模式</span></span><br><span class="line">  <span class="comment">// mode: &#x27;production&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4、运行指令：webpack-或-自定义脚本-npm-run-build"><a href="#4、运行指令：webpack-或-自定义脚本-npm-run-build" class="headerlink" title="4、运行指令：webpack 或 自定义脚本 npm run build"></a>4、运行指令：webpack 或 自定义脚本 npm run build</h3><h2 id="style-loader"><a href="#style-loader" class="headerlink" title="style-loader"></a>style-loader</h2><p>我们已经可以通过 css-loader 来加载 css 文件了</p><p>但是你会发现这个 css 在我们的代码中并没有生效（页面没有效果）。</p><p>这是为什么呢？</p><p>因为 css-loader 只是负责将.css 文件进行解析，并不会将解析之后的 css 插入到页面中；</p><p>如果我们希望再完成插入 style 的操作，那么我们还需要另外一个 loader，就是 style-loader；</p><p>安装 style-loader：<strong>npm install style-loader -D</strong></p><p>那么我们应该如何使用 style-loader：</p><p>在配置文件中，添加 style-loader，具体看上面代码</p><p>注意：因为 loader 的执行顺序是从右向左（或者说从下到上，或者说从后到前的），所以我们需要将 style- loader 写到 css-loader 的前面；</p><p>ps：当前目前我们的 css 是通过页内样式的方式添加进来的；</p><p>​ 后续我们也会讲如何将 css 抽取到单独的文件中，并且进行压缩等操作</p><h2 id="less-loader"><a href="#less-loader" class="headerlink" title="less-loader"></a>less-loader</h2><p>在我们开发中，我们可能会使用 less、sass、stylus 的预处理器来编写 css 样式，效率会更高。</p><p>那么，如何可以让我们的环境支持这些预处理器呢？</p><p>首先我们需要确定，less、sass 等编写的 css 需要通过工具转换成普通的 css；</p><p>比如我们编写如下的 less 样式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@<span class="attr">fsz</span>:20px;</span><br><span class="line">@<span class="attr">fsw</span>:<span class="string">&#x27;bold&#x27;</span>;</span><br><span class="line"></span><br><span class="line">.<span class="property">dv</span> &#123;</span><br><span class="line">  font-<span class="attr">size</span>: @fsz;</span><br><span class="line">  font-<span class="attr">weight</span>: @fsw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用 less 工具来完成它的编译转换：<strong>npm install less -D</strong></p><p>执行如下命令：<strong>npx lessc .&#x2F;src&#x2F;css&#x2F;title.less title.css</strong></p><p>但是在项目中我们会编写大量的 css，它们如何可以自动转换呢？</p><p>这个时候我们就可以使用 less-loader，来自动使用 less 工具转换 less 到 css；</p><p>此时我们需要<strong>配置 webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line"><span class="attr">use</span>: [</span><br><span class="line"><span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line"><span class="comment">// 将 less 文件编译成 css 文件</span></span><br><span class="line"><span class="comment">// 需要下载 less-loader 和 less</span></span><br><span class="line"><span class="string">&#x27;less-loader&#x27;</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PostCss"><a href="#PostCss" class="headerlink" title="PostCss"></a>PostCss</h2><h3 id="什么是-PostCSS-呢？"><a href="#什么是-PostCSS-呢？" class="headerlink" title="什么是 PostCSS 呢？"></a>什么是 PostCSS 呢？</h3><p>PostCSS 是一个通过 JavaScript 来转换样式的工具；</p><p>这个工具可以帮助我们进行一些 CSS 的转换和适配，比如自动添加浏览器前缀、css 样式的重置；</p><p>但是实现这些功能，我们需要借助于 PostCSS 对应的插件；</p><p>如何使用 PostCSS 呢？主要就是两个步骤：</p><p><strong>第一步：查找 PostCSS 在构建工具中的扩展，比如 webpack 中的 postcss-loader；</strong></p><p><strong>第二步：选择可以添加你需要的 PostCSS 相关的插件；</strong></p><p>当然，我们能不能也直接在终端使用 PostCSS 呢？</p><p>也是可以的，但是我们需要单独安装一个工具 postcss-cli；</p><p>我们可以安装一下它们：postcss、postcss-cli</p><p><strong>npm install postcss postcss-cli -D</strong></p><p>我们编写一个需要添加前缀的 css：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">dv</span> &#123;</span><br><span class="line">  <span class="comment">/* 页面文字不让选中 */</span></span><br><span class="line">  user-<span class="attr">select</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="autoprefixer"><a href="#autoprefixer" class="headerlink" title="autoprefixer"></a>autoprefixer</h3><p>因为我们需要添加前缀，所以要安装 autoprefixer：</p><p><strong>npm install autoprefixer -D</strong></p><p>直接使用使用 postcss 工具，并且制定使用 autoprefixer</p><p><strong>npx postcss –use autoprefixer -o end.css .&#x2F;src&#x2F;css&#x2F;style.css</strong></p><h3 id="postcss-loader"><a href="#postcss-loader" class="headerlink" title="postcss-loader"></a>postcss-loader</h3><p>真实开发中我们必然不会直接使用命令行工具来对 css 进行处理，而是可以借助于构建工具：</p><p>在 webpack 中使用 postcss 就是使用 postcss-loader 来处理的；</p><p>我们来安装 postcss-loader：</p><p><strong>npm install postcss-loader -D</strong></p><p>我们修改加载 css 的 loader：（配置文件已经过多，给出一部分了）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">loader</span>: <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">  <span class="attr">options</span>: &#123;</span><br><span class="line">  <span class="attr">postcssOptions</span>: &#123;</span><br><span class="line">  <span class="comment">// 使用插件</span></span><br><span class="line">  <span class="comment">// ps:因为postcss需要有对应的插件才会起效果，所以我们需要配置它的plugin；</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">  <span class="comment">// 引入插件</span></span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;autoprefixer&#x27;</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们也可以将这些配置信息放到一个单独的文件中进行管理：</p><p>在根目录下创建 postcss.config.js</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="built_in">require</span>(<span class="string">&quot;autoprefixer&quot;</span>)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="postcss-preset-env"><a href="#postcss-preset-env" class="headerlink" title="postcss-preset-env"></a>postcss-preset-env</h3><p>事实上，在配置 postcss-loader 时，我们配置插件并不需要使用 autoprefixer。</p><p>我们可以使用另外一个插件：postcss-preset-env</p><p>postcss-preset-env 也是一个 postcss 的插件；</p><p>它可以帮助我们将一些现代的 CSS 特性，转成大多数浏览器认识的 CSS，并且会根据目标浏览器或者运行时环境 添加所需的 polyfill；</p><p>也包括会自动帮助我们添加 autoprefixer（所以相当于已经内置了 autoprefixer）；</p><p>首先，我们需要安装 postcss-preset-env：</p><p><strong>npm install postcss-preset-env -D</strong></p><p>之后，我们直接修改掉之前的 autoprefixer 即可：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">loader</span>: <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">  <span class="attr">options</span>: &#123;</span><br><span class="line">  <span class="attr">postcssOptions</span>: &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;postcss-preset-env&#x27;</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打包-HTML-资源"><a href="#打包-HTML-资源" class="headerlink" title="打包 HTML 资源"></a>打包 HTML 资源</h2><h3 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h3><p>另外还有一个<strong>不太规范</strong>的地方：</p><p>我们的 HTML 文件是编写在根目录下的，而最终打包的 dist 文件夹中是没有 index.html 文件的。</p><p>在进行项目部署的时，必然也是需要有对应的入口文件 index.html；</p><p>所以我们也需要对 index.html 进行打包处理；</p><p>对 HTML 进行打包处理我们可以使用另外一个插件：<strong>HtmlWebpackPlugin；</strong></p><p>1、创建 html 页面</p><p>2、下载安装 plugin 包：npm install -D html-webpack-plugin</p><p>3、修改配置文件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// plugins的配置</span></span><br><span class="line">    <span class="comment">// html-webpack-plugin</span></span><br><span class="line">    <span class="comment">//功能：默认会创建一个空的 HTML，自动引入打包输出的所有资源（JS/CSS）</span></span><br><span class="line">    <span class="comment">//需求：需要有结构的 HTML文件</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">//复制 &#x27;./src/index.html&#x27;文件，并自动引入打包输出的所有资源（JS/CSS）</span></span><br><span class="line">      <span class="attr">template</span>: <span class="string">&quot;./src/index.html&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="打包图片资源"><a href="#打包图片资源" class="headerlink" title="打包图片资源"></a>打包图片资源</h2><h3 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h3><blockquote><p>参考文章：<a href="https://www.jianshu.com/p/c0de85a2d3fb">https://www.jianshu.com/p/c0de85a2d3fb</a></p></blockquote><h4 id="1、创建图片资源"><a href="#1、创建图片资源" class="headerlink" title="1、创建图片资源"></a>1、创建图片资源</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">方式一:</span><br><span class="line"><span class="keyword">let</span> dv = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">dv.<span class="property">className</span> = <span class="string">&#x27;box&#x27;</span></span><br><span class="line">dv.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;400px&#x27;</span></span><br><span class="line">dv.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&#x27;400px&#x27;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(dv)</span><br><span class="line"></span><br><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line">  background-<span class="attr">image</span>: <span class="title function_">url</span>(<span class="string">&#x27;../imgs/2.jpg&#x27;</span>);</span><br><span class="line">  background-<span class="attr">repeat</span>: no-repeat;</span><br><span class="line">  background-<span class="attr">size</span>: contain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方式二:</span><br><span class="line"><span class="keyword">import</span> imgUrl <span class="keyword">from</span> <span class="string">&#x27;./imgs/1.png&#x27;</span></span><br><span class="line"><span class="keyword">let</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line"><span class="comment">// img.src = &#x27;./imgs/1.png&#x27;</span></span><br><span class="line">img.<span class="property">src</span> = imgUrl</span><br><span class="line">img.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;400px&#x27;</span></span><br><span class="line">img.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&#x27;400px&#x27;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img)</span><br></pre></td></tr></table></figure><p>2、下载安装 loader 包 npm install –save-dev file-loader</p><p>3、修改配置文件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;built.js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|svg)$/</span>,</span><br><span class="line">        <span class="attr">use</span>: &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&quot;file-loader&quot;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">esModule</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&quot;imgs/[name]-[hash:5].[ext]&quot;</span>,</span><br><span class="line">            <span class="comment">// outputPath: imgs</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;javascript/auto&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="文件命名规则"><a href="#文件命名规则" class="headerlink" title="文件命名规则"></a>文件命名规则</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有时候我们处理后的文件名称按照一定的规则进行显示：</span><br><span class="line">比如保留原来的文件名、扩展名，同时为了防止重复，包含一个hash值等；</span><br><span class="line">这个时候我们可以使用PlaceHolders来完成，webpack给我们提供了大量的PlaceHolders来显示不同的内容：</span><br><span class="line">https://webpack.js.org/loaders/file-loader/#placeholders</span><br><span class="line">我们可以在文档中查阅自己需要的placeholder；</span><br><span class="line">我们这里介绍几个最常用的placeholder：</span><br><span class="line">[ext]： 处理文件的扩展名；</span><br><span class="line">[name]：处理文件的名称；</span><br><span class="line">[hash]：文件的内容，使用MD4的散列函数处理，生成的一个128位的hash值（32个十六进制）；</span><br><span class="line">[contentHash]：在file-loader中和[hash]结果是一致的（在webpack的一些其他地方不一样，后面会讲到）；</span><br><span class="line">[hash:&lt;length&gt;]：截图hash的长度，默认32个字符太长了；</span><br><span class="line">[path]：文件相对于webpack配置文件的路径；</span><br></pre></td></tr></table></figure><h3 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h3><p><strong>url-loader</strong>和<strong>file-loader</strong>的工作方式是相似的，但是可以将较小的文件，转成 base64 的 URI</p><p>安装：<strong>npm install url-loader -D</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|svg)$/i</span>,</span><br><span class="line">  <span class="attr">use</span>: &#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;[name]-[hash:5].[ext]&#x27;</span>,</span><br><span class="line">          <span class="attr">outputPath</span>: <span class="string">&#x27;imgs&#x27;</span>,</span><br><span class="line">          <span class="attr">limit</span>: <span class="number">20</span> * <span class="number">1024</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>显示结果是一样的，并且图片可以正常显示；</strong></p><p>但是在 dist 文件夹中，我们会看不到图片文件：</p><p>因为默认情况下 url-loader 会将所有的图片文件转成 base64 编码</p><p>但是开发中我们往往是小的图片需要转换，但是大的图片直接使用图片即可</p><p>这是因为小的图片转换 base64 之后可以和页面一起被请求，减少不必要的请求过程；</p><p>而大的图片也进行转换，反而会影响页面的请求速度；</p><p>那么，我们如何可以<strong>限制哪些大小的图片转换和不转换</strong>呢？</p><p>url-loader 有一个<strong>options</strong>属性<strong>limit</strong>，可以用于设置转换的限制；</p><blockquote><p><strong>url-loader 在 webpack5 中已废弃</strong><br>参考文章：<a href="https://www.jianshu.com/p/36e972b19b28">https://www.jianshu.com/p/36e972b19b28</a></p></blockquote><h3 id="html-loader"><a href="#html-loader" class="headerlink" title="html-loader"></a>html-loader</h3><p>在 html 中引入一张图片，npm run build 后发现该图片无法打包</p><p>解决方式：</p><p>安装 html-loader <strong>npm i html-loader -D</strong></p><p>修改配置文件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理html中的图片</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">test</span>: <span class="regexp">/\.(html|htm)$/</span>,</span><br><span class="line">   <span class="comment">// 处理html文件的img图片(负责引入img, 从而能被url-loader进行处理)</span></span><br><span class="line">   <span class="attr">loader</span>: <span class="string">&#x27;html-loader&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打包其它资源"><a href="#打包其它资源" class="headerlink" title="打包其它资源"></a>打包其它资源</h2><h3 id="1、引入字体图标"><a href="#1、引入字体图标" class="headerlink" title="1、引入字体图标"></a>1、引入字体图标</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> elI = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;i&quot;</span>);</span><br><span class="line">elI.<span class="property">className</span> = <span class="string">&quot;icomoon icon-heart&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(elI);</span><br></pre></td></tr></table></figure><p>2、下载 file-loader ：npm i file-loader -D</p><p>3、修改配置文件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新增规则 =&gt; 打包其他资源(除了 html/js/css资源以外的资源)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//排除 css/js/html资源</span></span><br><span class="line">   <span class="attr">exclude</span>: <span class="regexp">/\.(css|js|html|less)$/</span>,</span><br><span class="line">   <span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">   <span class="attr">options</span>: &#123;</span><br><span class="line">   <span class="attr">esModule</span>: <span class="literal">false</span>,</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&#x27;fonts/[hash:10].[ext]&#x27;</span></span><br><span class="line"> &#125;,</span><br><span class="line">   <span class="attr">type</span>: <span class="string">&#x27;javascript/auto&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h1 id="asset-module-type"><a href="#asset-module-type" class="headerlink" title="asset module type"></a>asset module type</h1><p>我们当前使用的 webpack 版本是 webpack5：</p><p>在 webpack5 之前，加载这些资源我们需要使用一些 loader，比如 raw-loader 、url-loader、file-loader；</p><p>在 webpack5 开始，我们可以直接使用资源模块类型（<strong>asset module type</strong>），来替代上面的这些 loader；</p><p>**资源模块类型(asset module type)**，通过添加 4 种新的模块类型，来替换所有这些 loader：</p><p><strong>asset&#x2F;resource</strong> 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现；</p><p><strong>asset&#x2F;inline</strong> 导出一个资源的 data URI。之前通过使用 url-loader 实现；</p><p><strong>asset&#x2F;source</strong> 导出资源的源代码。之前通过使用 raw-loader 实现；</p><p><strong>asset</strong> 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过 url-loader + limit 配置资源体积限制实现；</p><h3 id="比如打包图片："><a href="#比如打包图片：" class="headerlink" title="比如打包图片："></a>比如打包图片：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|svg)$/i</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;asset&#x27;</span>,</span><br><span class="line">    <span class="comment">// 生成器</span></span><br><span class="line">    <span class="attr">generator</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;img/[name].[hash:5][ext]&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 解析</span></span><br><span class="line">  <span class="attr">parser</span>: &#123;</span><br><span class="line">    <span class="comment">// 条件</span></span><br><span class="line">    <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">      <span class="comment">// 小于20kb的图片都转成base64位</span></span><br><span class="line">      <span class="attr">maxSize</span>: <span class="number">20</span> * <span class="number">1024</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="转-base64"><a href="#转-base64" class="headerlink" title="转 base64"></a>转 base64</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">因为不生成文件，所以没有generator属性</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|svg)$/i</span>,</span><br><span class="line"><span class="attr">type</span>: <span class="string">&#x27;asset/inline&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比如打包字体："><a href="#比如打包字体：" class="headerlink" title="比如打包字体："></a>比如打包字体：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(woff2?|eot|ttf)$/</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;asset/resource&#x27;</span>,</span><br><span class="line">  <span class="attr">generator</span>: &#123;</span><br><span class="line">     <span class="attr">filename</span>: <span class="string">&#x27;font/[name].[ext]&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Plugins-1"><a href="#Plugins-1" class="headerlink" title="Plugins"></a>Plugins</h1><p><strong>Webpack</strong> 的另一个核心是 Plugin，官方有这样一段对 Plugin 的描述：</p><p>While loaders are used to transform certain types of modules, plugins can be leveraged to perform a wider range of tasks like bundle optimization, asset management and injection of environment variables.</p><p>上面表达的含义翻译过来就是：</p><p>Loader 是用于特定的模块类型进行转换；</p><p>Plugin 可以用于执行更加广泛的任务，比如打包优化、资源管理、环境变量注入等</p><p><img src="/img/md/webpack10.png"></p><h2 id="CleanWebpackPlugin"><a href="#CleanWebpackPlugin" class="headerlink" title="CleanWebpackPlugin"></a>CleanWebpackPlugin</h2><p>前面我们演示的过程中，每次修改了一些配置，重新打包时，都需要手动删除 build 文件夹：</p><p>我们可以借助于一个插件来帮助我们完成，这个插件就是 CleanWebpackPlugin；</p><p>首先，我们先安装这个插件：</p><p><strong>npm install clean-webpack-plugin -D</strong></p><p>修改配置文件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CleanWebpackPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;clean-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="HtmlWebpackPlugin-1"><a href="#HtmlWebpackPlugin-1" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h2><p>对 HTML 进行打包处理我们可以使用另外一个插件：HtmlWebpackPlugin；</p><p>1、创建 html 页面</p><p>2、下载安装 plugin 包：npm install -D html-webpack-plugin</p><p>3、修改配置文件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// plugins的配置</span></span><br><span class="line">    <span class="comment">// html-webpack-plugin</span></span><br><span class="line">    <span class="comment">//功能：默认会创建一个空的 HTML，自动引入打包输出的所有资源（JS/CSS）</span></span><br><span class="line">    <span class="comment">//需求：需要有结构的 HTML文件</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">//复制 &#x27;./src/index.html&#x27;文件，并自动引入打包输出的所有资源（JS/CSS）</span></span><br><span class="line">      <span class="attr">template</span>: <span class="string">&quot;./src/index.html&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>自定义 html 模板</p><p>如果我们想在自己的模块中加入一些比较特别的内容：</p><p>比如添加一个 noscript 标签，在用户的 JavaScript 被关闭时，给予响应的提示；</p><p>比如在开发 vue 或者 react 项目时，我们需要一个可以挂载后续组件的根标签；</p><p>我们需要一个属于自己的模板</p><p>我们选择复制 vue 的 index.html 作为模板</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;noscript&gt;</span><br><span class="line">      &lt;strong&gt;We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt;</span><br><span class="line">    &lt;/noscript&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;!-- built files will be auto injected --&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>上面的代码中，会有一些类似这样的语法&lt;%&#x3D; 变量 %&gt;，这个是 EJS 模块填充数据的方式。</p><p>在配置 HtmlWebpackPlugin 时，我们可以添加如下配置：</p><p>template：指定我们要使用的模块所在的路径；</p><p>title：在进行 htmlWebpackPlugin.options.title 读取时，就会读到该信息；</p><p>但是，这个时候编译还是会报错，因为在我们的模块中还使用到一个<strong>BASE_URL</strong>的常量：</p><p><img src="/img/md/webpack11.png"></p><p>这是因为在编译 template 模块时，有一个 BASE_URL：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;icon&quot;</span> href=<span class="string">&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>但是我们并没有设置过这个常量值，所以会出现没有定义的错误；</p><p>这个时候我们可以使用 DefinePlugin 插件</p><h2 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h2><p>DefinePlugin 允许在编译时创建配置的全局常量，是一个 webpack 内置的插件（不需要单独安装）：</p><p><img src="/img/md/webpack12.png"></p><p>这个时候，编译 template 就可以正确的编译了，会读取到 BASE_URL 的值</p><h2 id="CopyWebpackPlugin"><a href="#CopyWebpackPlugin" class="headerlink" title="CopyWebpackPlugin"></a>CopyWebpackPlugin</h2><p>在 vue 的打包过程中，如果我们将一些文件放到 public 的目录下，那么这个目录会被复制到 dist 文件夹中。</p><p>这个复制的功能，我们可以使用 CopyWebpackPlugin 来完成；</p><p>安装 CopyWebpackPlugin 插件：</p><p><strong>npm install copy-webpack-plugin -D</strong></p><p>接下来<strong>配置 CopyWebpackPlugin</strong>即可：</p><p>复制的规则在 patterns 中设置；</p><p><strong>from：</strong>设置从哪一个源中开始复制；</p><p><strong>to：</strong>复制到的位置，可以省略，会默认复制到打包的目录下；</p><p><strong>globOptions：</strong>设置一些额外的选项，其中可以编写需要忽略的文件：</p><p>.DS_Store：mac 目录下回自动生成的一个文件；</p><p>index.html：也不需要复制，因为我们已经通过 HtmlWebpackPlugin 完成了 index.html 的生成；</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title function_">copyWebpackPlugin</span>(&#123;</span><br><span class="line">  <span class="attr">patterns</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">from</span>: <span class="string">&#x27;public&#x27;</span>,</span><br><span class="line">      <span class="attr">globOptions</span>: &#123;</span><br><span class="line">        <span class="comment">// 忽略</span></span><br><span class="line">        <span class="attr">ignore</span>: [</span><br><span class="line">          <span class="string">&#x27;**/.DS_Store&#x27;</span></span><br><span class="line">          <span class="string">&#x27;**/index.html&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="Babel-相关"><a href="#Babel-相关" class="headerlink" title="Babel 相关"></a>Babel 相关</h1><p>事实上，在开发中我们很少直接去接触 babel，但是 <strong>babel</strong> 对于前端开发来说，目前是不可缺少的一部分：</p><p>开发中，我们想要使用 ES6+的语法，想要使用 TypeScript，开发 React 项目，它们都是离不开 Babel 的；</p><p>所以，学习 Babel 对于我们理解代码从编写到线上的转变过程至关重要；</p><p>那么，<strong>Babel 到底是什么呢？</strong></p><p>Babel 是一个工具链，主要用于旧浏览器或者环境中将 ECMAScript 2015+代码转换为向后兼容版本的 JavaScript；</p><p>包括：语法转换、源代码转换等；</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = (<span class="number">10</span>)[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)].<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Babel-命令行使用"><a href="#Babel-命令行使用" class="headerlink" title="Babel 命令行使用"></a>Babel 命令行使用</h3><p>babel 本身可以作为<strong>一个独立的工具</strong>（和 postcss 一样），不和 webpack 等构建工具配置来单独使用。</p><p>如果我们希望在命令行尝试使用 babel，需要安装如下库：</p><p>@babel&#x2F;core：babel 的核心代码，必须安装；</p><p>@babel&#x2F;cli：可以让我们在命令行使用 babel；</p><p><strong>npm install @babel&#x2F;cli @babel&#x2F;core -D</strong></p><p>使用 babel 来处理我们的源代码：</p><p>src：是源文件的目录；</p><p>–out-dir：指定要输出的文件夹 dist；</p><p><strong>npx babel src –out-dir dist</strong></p><h3 id="插件的使用"><a href="#插件的使用" class="headerlink" title="插件的使用"></a>插件的使用</h3><p>比如我们需要转换箭头函数，那么我们就可以使用<strong>箭头函数转换相关的插件</strong></p><p><strong>npm install @babel&#x2F;plugin-transform-arrow-functions -D</strong></p><p><strong>npx babel src –out-dir dist --plugins&#x3D;@babel&#x2F;plugin-transform-arrow-functions</strong></p><p>查看转换后的结果：我们会发现 const 并没有转成 var</p><p>这是因为 plugin-transform-arrow-functions，并没有提供这样的功能；</p><p>我们需要使用 plugin-transform-block-scoping 来完成这样的功能；</p><p><strong>npm install @babel&#x2F;plugin-transform-block-scoping -D</strong></p><p><strong>npx babel src –out-dir dist --plugins&#x3D;@babel&#x2F;plugin-transform-block-scoping,@babel&#x2F;plugin-transform-arrow-functions</strong></p><h3 id="Babe-的预设-preset"><a href="#Babe-的预设-preset" class="headerlink" title="Babe 的预设 preset"></a>Babe 的预设 preset</h3><p>但是如果要转换的内容过多，一个个设置是比较麻烦的，我们可以使用预设（preset）：</p><p>后面我们再具体来讲预设代表的含义；</p><p>安装@babel&#x2F;preset-env 预设：</p><p><strong>npm install @babel&#x2F;preset-env -D</strong></p><p>执行如下命令：</p><p><strong>npx babel src –out-dir dist --presets&#x3D;@babel&#x2F;preset-env</strong></p><h3 id="Babel-的底层原理"><a href="#Babel-的底层原理" class="headerlink" title="Babel 的底层原理"></a>Babel 的底层原理</h3><p>babel 是如何做到将我们的一段代码（ES6、TypeScript、React）转成另外一段代码（ES5）的呢？</p><p>从一种源代码（原生语言）转换成另一种源代码（目标语言），这是什么的工作呢？</p><p>就是<strong>编译器</strong>，事实上我们可以将 babel 看成就是一个编译器。</p><p>Babel 编译器的作用就是将我们的源代码，转换成浏览器可以直接识别的另外一段源代码；</p><h3 id="Babel-也拥有编译器的工作流程："><a href="#Babel-也拥有编译器的工作流程：" class="headerlink" title="Babel 也拥有编译器的工作流程："></a>Babel 也拥有编译器的工作流程：</h3><ul><li>解析阶段（Parsing)</li><li>转换阶段（Transformation）</li><li>生成阶段（Code Generation）</li></ul><blockquote><p>参考：<a href="https://github.com/jamiebuilds/the-super-tiny-compiler">https://github.com/jamiebuilds/the-super-tiny-compiler</a></p></blockquote><h3 id="Babel-编译器执行原理"><a href="#Babel-编译器执行原理" class="headerlink" title="Babel 编译器执行原理"></a>Babel 编译器执行原理</h3><p><img src="/img/md/webpack13.png"></p><p>当然，这只是一个简化版的编译器工具流程，在每个阶段又会有自己具体的工作</p><p><img src="/img/md/webpack14.png"></p><h3 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h3><p>在实际开发中，我们通常会在构建工具中通过配置 babel 来对其进行使用的，比如在 webpack 中。</p><p>那么我们就需要去安装相关的依赖：</p><p>如果之前已经安装了@babel&#x2F;core，那么这里不需要再次安装；</p><p><strong>npm install babel-loader @babel&#x2F;core</strong></p><p>我们可以设置一个规则，在加载 js 文件时，使用我们的 babel</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/.js$/</span>,</span><br><span class="line">    <span class="attr">use</span>: &#123;</span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="comment">// 指定使用的插件</span></span><br><span class="line">      <span class="comment">// plugins: [</span></span><br><span class="line">      <span class="comment">//   &quot;@babel/plugin-transform-arrow-functions&quot;,</span></span><br><span class="line">      <span class="comment">//   &quot;@babel/plugin-transform-block-scoping&quot;</span></span><br><span class="line">      <span class="comment">// ]</span></span><br><span class="line">      <span class="comment">// 指定预设环境</span></span><br><span class="line">      <span class="comment">// presets: [</span></span><br><span class="line">      <span class="comment">//   [&quot;@babel/preset-env&quot;]</span></span><br><span class="line">      <span class="comment">// ]</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="babel-x2F-preset-env"><a href="#babel-x2F-preset-env" class="headerlink" title="babel&#x2F;preset-env"></a>babel&#x2F;preset-env</h2><p>如果我们一个个去安装使用插件，那么需要手动来管理大量的 babel 插件，我们可以直接给 webpack 提供一个 preset，webpack 会根据我们的预设来加载对应的插件列表，并且将其传递给 babel。</p><p>比如常见的预设有三个：</p><ul><li>env</li><li>react</li><li>TypeScript</li></ul><p>安装 preset-env：</p><p><strong>npm install @babel&#x2F;preset-env</strong></p><p>配置文件修改看上面</p><h2 id="babel-配置文件"><a href="#babel-配置文件" class="headerlink" title="babel 配置文件"></a>babel 配置文件</h2><p>像之前一样，我们可以将 babel 的配置信息放到一个独立的文件中，babel 给我们提供了两种配置文件的编写：</p><p>babel.config.json（或者.js，.cjs，.mjs）文件；</p><p>.babelrc.json（或者.babelrc，.js，.cjs，.mjs）文件；</p><p>它们两个有什么区别呢？目前很多的项目都采用了多包管理的方式（babel 本身、element-plus、umi 等）；</p><p>.babelrc.json：早期使用较多的配置方式，但是对于配置 Monorepos 项目是比较麻烦的；</p><p>babel.config.js（babel7）：可以直接作用于 Monorepos 项目的子包，更加推荐；</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="corejs"><a href="#corejs" class="headerlink" title="corejs"></a>corejs</h2><p><strong>js 兼容性处理：babel-loader @babel&#x2F;core</strong></p><ul><li>基本 js 兼容性处理 –&gt; @babel&#x2F;preset-env<ul><li>问题：只能转换基本语法，如 promise 高级语法不能转换</li></ul></li><li>全部 js 兼容性处理 –&gt; @babel&#x2F;polyfill</li><li>问题：我只要解决部分兼容性问题，但是将所有兼容性代码全部引入，体积太大了~</li><li>需要做兼容性处理的就做：按需加载 –&gt; core-js</li></ul><p>配置文件修改</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">    <span class="comment">// 预设：指示babel做怎么样的兼容性处理</span></span><br><span class="line">    <span class="attr">presets</span>: [</span><br><span class="line">      [</span><br><span class="line">        <span class="string">&#x27;@babel/preset-env&#x27;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 按需加载</span></span><br><span class="line">          <span class="attr">useBuiltIns</span>: <span class="string">&#x27;usage&#x27;</span>,</span><br><span class="line">          <span class="comment">// 指定core-js版本</span></span><br><span class="line">          <span class="attr">corejs</span>: &#123;</span><br><span class="line">            <span class="attr">version</span>: <span class="number">3</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 指定兼容性做到哪个版本浏览器</span></span><br><span class="line">          <span class="attr">targets</span>: &#123;</span><br><span class="line">            <span class="attr">chrome</span>: <span class="string">&#x27;60&#x27;</span>,</span><br><span class="line">            <span class="attr">firefox</span>: <span class="string">&#x27;60&#x27;</span>,</span><br><span class="line">            <span class="attr">ie</span>: <span class="string">&#x27;9&#x27;</span>,</span><br><span class="line">            <span class="attr">safari</span>: <span class="string">&#x27;10&#x27;</span>,</span><br><span class="line">            <span class="attr">edge</span>: <span class="string">&#x27;17&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h2><p>我们希望通过 eslint 对 js 语法进行检查 目的为了统一编码规范</p><p>1、官网查找 eslint-loader 发现过期了 官网推荐使用 eslint-webpack-plugin<br>2、找到 eslint-webpack-plugin 包 提示需要安装 eslint 包<br>3、安装完以后 webpack 执行命令报错 src 路径下缺少.eslintrc.js 文件(自定义校验规则文件)<br>4、在 src 下新增**.eslintrc.js**文件 自定义编码规则 webpack 执行检查是否生效</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="attr">browser</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">es6</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">node</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">extends</span>: <span class="string">&quot;eslint:recommended&quot;</span>,</span><br><span class="line">  <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">    <span class="attr">ecmaVersion</span>: <span class="number">2015</span>,</span><br><span class="line">    <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="comment">// 缩进</span></span><br><span class="line">    <span class="attr">indent</span>: [</span><br><span class="line">      <span class="string">&quot;error&quot;</span>,</span><br><span class="line">      <span class="number">4</span>, <span class="comment">//我的是编辑器自动格式化，不是使用tabs，而是四个空格</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;linebreak-style&quot;</span>: [<span class="string">&quot;error&quot;</span>, <span class="string">&quot;windows&quot;</span>], <span class="comment">// 引号</span></span><br><span class="line">    <span class="attr">quotes</span>: [<span class="number">1</span>, <span class="string">&quot;single&quot;</span>], <span class="comment">// 分号结尾</span></span><br><span class="line">    <span class="attr">semi</span>: [<span class="string">&quot;error&quot;</span>, <span class="string">&quot;always&quot;</span>],</span><br><span class="line">    <span class="string">&quot;no-unused-vars&quot;</span>: [</span><br><span class="line">      <span class="number">2</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 允许声明未使用变量</span></span><br><span class="line">        <span class="attr">vars</span>: <span class="string">&quot;local&quot;</span>, <span class="comment">// 参数不检查</span></span><br><span class="line">        <span class="attr">args</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ], <span class="comment">// 最大空行100</span></span><br><span class="line">    <span class="string">&quot;no-multiple-empty-lines&quot;</span>: [<span class="number">0</span>, &#123; <span class="attr">max</span>: <span class="number">100</span> &#125;],</span><br><span class="line">    <span class="string">&quot;no-mixed-spaces-and-tabs&quot;</span>: [<span class="number">0</span>], <span class="comment">//不能使用console</span></span><br><span class="line">    <span class="string">&quot;no-console&quot;</span>: <span class="string">&quot;off&quot;</span>, <span class="comment">//未定义变量不能使用</span></span><br><span class="line">    <span class="string">&quot;no-undef&quot;</span>: <span class="number">0</span>, <span class="comment">//一行结束后面不要有空格</span></span><br><span class="line">    <span class="string">&quot;no-trailing-spaces&quot;</span>: <span class="number">1</span>, <span class="comment">//强制驼峰法命名</span></span><br><span class="line">    <span class="attr">camelcase</span>: <span class="number">2</span>, <span class="comment">//对象字面量项尾不能有逗号</span></span><br><span class="line">    <span class="string">&quot;comma-dangle&quot;</span>: [<span class="number">2</span>, <span class="string">&quot;never&quot;</span>], <span class="comment">//this别名</span></span><br><span class="line">    <span class="string">&quot;consistent-this&quot;</span>: [<span class="number">2</span>, <span class="string">&quot;that&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>5、查找 eslint-config-airbnb-base 包 提示如果要支持 es6 以上的语法需要安装 eslint-plugin-import 和 eslint<br>6、安装完成后 配置 package.json 文件 继承 airbnb-base 校验规则<br>7、执行 webpack 检查校验规则是否生效</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">语法检查： eslint-loader  eslint</span><br><span class="line">注意：只检查自己写的源代码，第三方的库是不用检查的</span><br><span class="line">设置检查规则：</span><br><span class="line">package.<span class="property">json</span>中eslintConfig中设置~</span><br><span class="line">  <span class="string">&quot;eslintConfig&quot;</span>: &#123;</span><br><span class="line">     <span class="string">&quot;extends&quot;</span>: <span class="string">&quot;airbnb-base&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">airbnb --&gt; eslint-config-airbnb-base  eslint-plugin-<span class="keyword">import</span> eslint</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">  <span class="title function_">newESLintPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">fix</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="搭建本地服务器"><a href="#搭建本地服务器" class="headerlink" title="搭建本地服务器"></a>搭建本地服务器</h2><p>为什么要搭建？</p><p>目前我们开发的代码，为了运行需要有两个操作：</p><p>操作一：npm run build，编译相关的代码；</p><p>操作二：通过 live server 或者直接通过浏览器，打开 index.html 代码，查看效果；</p><p>这个过程经常操作会影响我们的开发效率，我们希望可以做到，当文件发生变化时，可以自动的完成 编译 和 展示；</p><p>为了完成自动编译，webpack 提供了几种可选的方式：</p><p>1、webpack watch mode；<br>2、webpack-dev-server（常用）；<br>3、webpack-dev-middleware；</p><h3 id="Webpack-watch"><a href="#Webpack-watch" class="headerlink" title="Webpack watch"></a>Webpack watch</h3><p>webpack 给我们提供了 watch 模式：</p><p>在该模式下，webpack 依赖图中的所有文件，只要有一个发生了更新，那么代码将被重新编译；</p><p>我们不需要手动去运行 npm run build 指令了；</p><p>如何开启 watch 呢？两种方式：</p><ul><li>方式一：在导出的配置中，添加 watch: true；</li><li>方式二：在启动 webpack 的命令中，添加 –watch 的标识；</li></ul><p>这里我们选择方式二，在 package.json 的 scripts 中添加一个 watch 的脚本：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;npx webpack&quot;</span>,</span><br><span class="line">    <span class="string">&quot;watch&quot;</span>: <span class="string">&quot;webpack --watch&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>上面的方式可以监听到文件的变化，但是事实上它本身是没有自动刷新浏览器的功能的：</p><p>当然，目前我们可以在 VSCode 中使用 live-server 来完成这样的功能；</p><p>但是，我们希望在不使用 live-server 的情况下，可以具备 live reloading（实时重新加载）的功能；</p><p>安装 webpack-dev-server</p><p><strong>npm install webpack-dev-server -D</strong></p><p>修改配置文件，告知 dev server，从什么位置查找文件：</p><p>contentBase 已经从 webpack5 中移除 使用 static 取代</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="comment">// 主要是指定静态资源的根目录的 下面这种方式已废弃</span></span><br><span class="line">    <span class="comment">// contentBase: &#x27;./public&#x27;,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// webpack5最新的方式</span></span><br><span class="line">    <span class="attr">static</span>: &#123;</span><br><span class="line">       <span class="attr">directory</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;public&#x27;</span>),</span><br><span class="line">     &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>webpack-dev-server 在编译之后不会写入到任何输出文件。而是将 bundle 文件保留在内存中：事实上 webpack-dev-server 使用了一个库叫 memfs（memory-fs webpack 自己写的）</p><h2 id="认识模块热替换（HMR）"><a href="#认识模块热替换（HMR）" class="headerlink" title="认识模块热替换（HMR）"></a>认识模块热替换（HMR）</h2><p>什么是 HMR 呢？</p><p>HMR 的全称是 Hot Module Replacement，翻译为模块热替换；</p><p>模块热替换是指在 应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个页面；</p><p>HMR 通过如下几种方式，来提高开发的速度：</p><p>不重新加载整个页面，这样可以保留某些应用程序的状态不丢失；</p><p>只更新需要变化的内容，节省开发的时间；</p><p>修改了 css、js 源代码，会立即在浏览器更新，相当于直接在浏览器的 devtools 中直接修改样式；</p><p>如何使用 HMR 呢？</p><p>默认情况下，webpack-dev-server 已经支持 HMR，我们只需要开启即可；</p><p>在不开启 HMR 的情况下，当我们修改了源代码之后，整个页面会自动刷新，使用的是 live reloading</p><h3 id="开启-HMR"><a href="#开启-HMR" class="headerlink" title="开启 HMR"></a>开启 HMR</h3><p>修改配置文件:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line"><span class="attr">static</span>: &#123;</span><br><span class="line">       <span class="attr">directory</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;public&#x27;</span>),</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="attr">hot</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器控制台查看效果</p><p><img src="/img/md/webpack15.png"></p><p>但是你会发现，当我们修改了某一个模块的代码时，依然是刷新的整个页面：</p><p>这是因为我们需要去指定哪些模块发生更新时，进行 HMR；</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./a.js&quot;</span>;</span><br><span class="line"><span class="comment">// 指定哪些模块发生更新时进行HMR</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">module</span>.<span class="property">hot</span>) &#123;</span><br><span class="line">  <span class="comment">// accept: 认可 同意</span></span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">hot</span>.<span class="title function_">accept</span>(<span class="string">&quot;./a.js&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a.js已经更新啦~~~~~~&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="框架的-HMR"><a href="#框架的-HMR" class="headerlink" title="框架的 HMR"></a>框架的 HMR</h2><p>有一个问题：在开发其他项目时，我们是否需要经常手动去写入 module.hot.accpet 相关的 API 呢？</p><p>比如开发 Vue、React 项目，我们修改了组件，希望进行热更新，这个时候应该如何去操作呢？</p><p>事实上社区已经针对这些有很成熟的解决方案了：</p><p>比如 vue 开发中，我们使用 vue-loader，此 loader 支持 vue 组件的 HMR，提供开箱即用的体验；</p><p>比如 react 开发中，有 React Hot Loader，实时调整 react 组件（目前 React 官方已经弃用了，改成使用 react- refresh）；</p><h2 id="HRM-原理"><a href="#HRM-原理" class="headerlink" title="HRM 原理"></a>HRM 原理</h2><p>那么 HMR 的原理是什么呢？如何可以做到只更新一个模块中的内容呢？</p><p>webpack-dev-server 会创建两个服务：提供静态资源的服务（express）和 Socket 服务（net.Socket）；</p><p>express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）；</p><p>HMR Socket Server，是一个 socket 的长连接：</p><p>长连接有一个最好的好处是建立连接后双方可以通信（服务器可以直接发送文件到客户端）；</p><p>当服务器监听到对应的模块发生变化时，会生成两个文件.json（manifest 文件）和.js 文件（update chunk）；</p><p>通过长连接，可以直接将这两个文件主动发送给客户端（浏览器）；</p><p>浏览器拿到两个新的文件后，通过 HMR runtime 机制，加载这两个文件，并且针对修改的模块进行更新；</p><p><img src="/img/md/webpack16.png"></p><h2 id="hotOnly、host-配置"><a href="#hotOnly、host-配置" class="headerlink" title="hotOnly、host 配置"></a>hotOnly、host 配置</h2><p>host 设置主机地址：</p><p>默认值是 localhost；</p><p>如果希望其他地方也可以访问，可以设置为 0.0.0.0；</p><p>localhost 和 0.0.0.0 的区别：</p><p>localhost：本质上是一个域名，通常情况下会被解析成 127.0.0.1;</p><p>127.0.0.1：回环地址(Loop Back Address)，表达的意思其实是我们主机自己发出去的包，直接被自己接收;</p><p>正常的数据库包发送过程 应用层 - 传输层 - 网络层 - 数据链路层 - 物理层 ;</p><p>而回环地址，是在网络层直接就被获取到了，是不会经常数据链路层和物理层的;</p><p>比如我们监听 127.0.0.1 时，在同一个网段下的主机中，通过 ip 地址是不能访问的;</p><p>0.0.0.0：监听 IPV4 上所有的地址，再根据端口找到不同的应用程序;</p><p>比如我们监听 0.0.0.0 时，在同一个网段下的主机中，通过 ip 地址是可以访问的;</p><p><strong>port、open、compress</strong></p><p>port 设置监听的端口，默认情况下是 8080</p><p>open 是否打开浏览器：</p><p>默认值是 false，设置为 true 会打开浏览器；</p><p>也可以设置为类似于 Google Chrome 等值；</p><p>compress 是否为静态文件开启 gzip compression：</p><p>默认值是 false，可以设置为 true；</p><p><img src="/img/md/webpack17.png"></p><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>roxy 是我们开发中非常常用的一个配置选项，它的目的设置代理来解决跨域访问的问题：</p><p>比如我们的一个 api 请求是 <a href="http://localhost:8888，">http://localhost:8888，</a> 但是本地启动服务器的域名是 <a href="http://localhost:8000，">http://localhost:8000，</a> 这个时候发送网络请求就会出现跨域的问题；</p><p>那么我们可以将请求先发送到一个代理服务器，代理服务器和 API 服务器没有跨域的问题，就可以解决我们的跨</p><p>域问题了；</p><p>我们可以进行如下的设置：</p><ul><li>target：表示的是代理到的目标地址，比如 &#x2F;api-hy&#x2F;moment 会被代理到 <a href="http://localhost:8888/api-hy/moment%EF%BC%9B">http://localhost:8888/api-hy/moment；</a></li><li>pathRewrite：默认情况下，我们的 &#x2F;api-hy 也会被写入到 URL 中，如果希望删除，可以使用 pathRewrite；</li><li>secure：默认情况下不接收转发到 https 的服务器上，如果希望支持，可以设置为 false；</li><li>changeOrigin：它表示是否更新代理后请求的 headers 中 host 地址；</li></ul><h2 id="changeOrigin"><a href="#changeOrigin" class="headerlink" title="changeOrigin"></a>changeOrigin</h2><p>这个 changeOrigin 官方说的非常模糊，通过查看源码我发现其实是要修改代理请求中的 headers 中的 host 属性：</p><p>因为我们真实的请求，其实是需要通过 <a href="http://localhost:8888/">http://localhost:8888</a> 来请求的；</p><p>但是因为使用了代码，默认情况下它的值时 <a href="http://localhost:8000/">http://localhost:8000</a> ；</p><p>如果我们需要修改，那么可以将 changeOrigin 设置为 true 即可；</p><p><img src="/img/md/webpack18.png"></p><h2 id="historyApiFallback"><a href="#historyApiFallback" class="headerlink" title="historyApiFallback"></a>historyApiFallback</h2><p>historyApiFallback 是开发中一个非常常见的属性，它主要的作用是解决 SPA 页面在路由跳转之后，进行页面刷新 时，返回 404 的错误。</p><p>boolean 值：默认是 false</p><p>如果设置为 true，那么在刷新时，返回 404 错误时，会自动返回 index.html 的内容；</p><p>object 类型的值，可以配置 rewrites 属性：</p><p>可以配置 from 来匹配路径，决定要跳转到哪一个页面；</p><p>事实上 devServer 中实现 historyApiFallback 功能是通过 connect-history-api-fallback 库的：</p><p>可以查看 connect-history-api-fallback 文档</p><h2 id="resolve-模块解析"><a href="#resolve-模块解析" class="headerlink" title="resolve 模块解析"></a>resolve 模块解析</h2><p>resolve 用于设置模块如何被解析：</p><p>在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库；</p><p>resolve 可以帮助 webpack 从每个 require&#x2F;import 语句中，找到需要引入到合适的模块代码；</p><p>webpack 使用 enhanced-resolve 来解析文件路径；</p><h3 id="webpack-能解析三种文件路径："><a href="#webpack-能解析三种文件路径：" class="headerlink" title="webpack 能解析三种文件路径："></a>webpack 能解析三种文件路径：</h3><ul><li>绝对路径<ul><li>由于已经获得文件的绝对路径，因此不需要再做进一步解析。</li></ul></li><li>相对路径<ul><li>在这种情况下，使用 import 或 require 的资源文件所处的目录，被认为是上下文目录；</li><li>在 import&#x2F;require 中给定的相对路径，会拼接此上下文路径，来生成模块的绝对路径；</li></ul></li><li>模块路径<ul><li>在 resolve.modules 中指定的所有目录检索模块；</li><li>默认值是 [‘node_modules’]，所以默认会从 node_modules 中查找文件；</li><li>我们可以通过设置别名的方式来替换初识模块路径，具体后面讲解 alias 的配置；</li></ul></li></ul><h3 id="确实文件还是文件夹"><a href="#确实文件还是文件夹" class="headerlink" title="确实文件还是文件夹"></a>确实文件还是文件夹</h3><p>如果是一个文件：</p><p>如果文件具有扩展名，则直接打包文件；</p><p>否则，将使用 resolve.extensions 选项作为文件扩展名解析；</p><p>如果是一个文件夹：</p><p>会在文件夹中根据 resolve.mainFiles 配置选项中指定的文件顺序查找；</p><p>resolve.mainFiles 的默认值是 [‘index’]；</p><p>再根据 resolve.extensions 来解析扩展名；</p><h2 id="extensions-和-alias-配置"><a href="#extensions-和-alias-配置" class="headerlink" title="extensions 和 alias 配置"></a>extensions 和 alias 配置</h2><p>extensions 是解析到文件时自动添加扩展名：</p><p>默认值是 [‘.wasm’, ‘.mjs’, ‘.js’, ‘.json’]；</p><p>所以如果我们代码中想要添加加载 .vue 或者 jsx 或者 ts 等文件时，我们必须自己写上扩展名；</p><p>另一个非常好用的功能是配置别名 alias：</p><p>特别是当我们项目的目录结构比较深的时候，或者一个文件的路径可能需要 …&#x2F;…&#x2F;…&#x2F;这种路径片段；</p><p>我们可以给某些常见的路径起一个别名；</p><p><img src="/img/md/webpack19.png"></p><h1 id="webpack-生产环境配置"><a href="#webpack-生产环境配置" class="headerlink" title="webpack 生产环境配置"></a>webpack 生产环境配置</h1><h2 id="css-提取"><a href="#css-提取" class="headerlink" title="css 提取"></a>css 提取</h2><p>下载插件 <strong>npm install –save-dev mini-css-extract-plugin</strong></p><p>修改配置</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"><span class="attr">rules</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    <span class="attr">use</span>: [</span><br><span class="line">      <span class="comment">//创建 style标签，将样式放入</span></span><br><span class="line">      <span class="comment">// &#x27;style-loader&#x27;,</span></span><br><span class="line">      <span class="comment">//这个 loader取代 style-loader。作用：提取 js中的 css成单独文件</span></span><br><span class="line">      <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,</span><br><span class="line">      <span class="comment">//将 css文件整合到 js文件中</span></span><br><span class="line">      <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">    <span class="comment">//对输出的 css文件进行重命名</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;css/built.css&quot;</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="css-兼容"><a href="#css-兼容" class="headerlink" title="css 兼容"></a>css 兼容</h2><p>往上翻 postcss-preset-env</p><h2 id="css-压缩"><a href="#css-压缩" class="headerlink" title="css 压缩"></a>css 压缩</h2><p>下载插件 <strong>npm install –save-dev optimize-css-assets-webpack-plugin</strong></p><p>webpack5 改用 <strong>npm i -D css-minimizer-webpack-plugin</strong></p><p>修改配置文件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">OptimizeCssAssetsWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;optimize-css-assets-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="attr">plugins</span>: [<span class="keyword">new</span> <span class="title class_">OptimizeCssAssetsWebpackPlugin</span>()];</span><br></pre></td></tr></table></figure><h2 id="js-语法检查"><a href="#js-语法检查" class="headerlink" title="js 语法检查"></a>js 语法检查</h2><p>往上翻 eslint</p><h2 id="js-兼容处理"><a href="#js-兼容处理" class="headerlink" title="js 兼容处理"></a>js 兼容处理</h2><p>往上翻 babel</p><h2 id="js-压缩"><a href="#js-压缩" class="headerlink" title="js 压缩"></a>js 压缩</h2><p>生产环境下会自动压缩 js 代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="HTML压缩"><a href="#HTML压缩" class="headerlink" title="HTML压缩"></a>HTML压缩</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>,</span><br><span class="line">    <span class="comment">//压缩 html代码</span></span><br><span class="line">    <span class="attr">minify</span>: &#123;</span><br><span class="line">      <span class="comment">//移除空格</span></span><br><span class="line">      <span class="attr">collapseWhitespace</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">//移除注释</span></span><br><span class="line">      <span class="attr">removeComments</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 移除空元素</span></span><br><span class="line">      <span class="attr">removeEmptyElements</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 2.0</title>
      <link href="/2021/09/27/vue/Vue2/"/>
      <url>/2021/09/27/vue/Vue2/</url>
      
        <content type="html"><![CDATA[<h1 id="VUE-js框架是什么？为什么要学它"><a href="#VUE-js框架是什么？为什么要学它" class="headerlink" title="VUE.js框架是什么？为什么要学它"></a>VUE.js框架是什么？为什么要学它</h1><ul><li>vue作为国人开发的一款前端框架，不仅有强大的社区支持，很多API都是中文的，学习难度相对较小</li><li>接收用户输入的同时，很可能要及时更新视图，比如用户输入不同的内容，页面就会相对应进行更新，点击不同的选项，显示不同的状态等交互效果。（用vue更便捷）</li></ul><h2 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h2><p>视图数据混在一起冗繁复杂，把html中的dom与其他部分独立开来划分出一个层次，这个层次就叫做视图层，vue的核心库只关注视图层</p><h2 id="BTW——API"><a href="#BTW——API" class="headerlink" title="BTW——API"></a>BTW——API</h2><ul><li>例：电脑需要调用手机里的信息，用数据线进行连接，电脑和手机连接数据线的接口就是API</li></ul><h3 id="API与上述例子类似又不尽相同"><a href="#API与上述例子类似又不尽相同" class="headerlink" title="API与上述例子类似又不尽相同"></a>API与上述例子类似又不尽相同</h3><ul><li>定义：应用程序接口，是一些预先定义的接口（如函数，http接口），或软件系统不同组成部分衔接的约定）</li><li>应用场景：<ul><li>接口：前后端交互</li><li>提供应用程序与开发人员基于某软件或硬件得以访问的一组历程，而又无需访问源码<br>  例：程序员B想调用A中的部分功能又不想从头看一遍A的源码和功能实现过程，这时候把A需要的功能打包好，写成一个函数！！！按照B说的流程把函数放在B中就可以直接使用功能了</li></ul></li></ul><h1 id="vue是什么？"><a href="#vue是什么？" class="headerlink" title="vue是什么？"></a>vue是什么？</h1><ul><li>定义：以数据驱动视图的MVVM渐进式框架<ul><li>数据：对象</li><li>视图：dom标签 –&gt; 虚拟dom</li><li>MVVM：M model模型，V view视图。就是一种框架架构，model-view view-model， 这样的结构，主要优势在于监控者数据双向绑定的特性，vue和model之间是双向数据传递的。视图改变数据就可以改变，数据改变视图就可以改变。</li><li>渐进式：轻量级框架，可以选择性的，只使用vue中很少的一部分，而不是必须使用全部</li></ul></li></ul><h2 id="BTW——MVC和MVVM"><a href="#BTW——MVC和MVVM" class="headerlink" title="BTW——MVC和MVVM"></a>BTW——MVC和MVVM</h2><ul><li>MVVM有两个方向：<ol><li>将model（模型）转化成 view（视图），即后端传递的数据转化成所看到的页面。实现方式为数据绑定</li><li>将view（视图）转化成 model（模型），即将所看的页面转化成后端的数据。实现方式为dom监听事件</li></ol></li><li>什么是mvc?<ul><li>MVC是model-view-controller的缩写，即模型——视图——控制器。M和V指的意思和MVVM中的M和V意思一样。C即Controller指的是页面业务逻辑。使用MVC的目的就是将M和V的代码分离。MVC是单向通信。也就是View跟Model，必须通过Controller来承上启下。</li></ul></li><li>区别：<ul><li>MVC和MVVM的区别并不是VM完全取代了C，只是在MVC的基础上增加了一层VM，只不过是弱化了C的概念，ViewModel存在目的在于抽离Controller中展示的业务逻辑，而不是替代Controller，其它视图操作业务等还是应该放在Controller中实现。</li><li>View更新的时候，必须要通过Controller去更新一遍Model；同样的Model更新的时候，也要去更新一遍视图。<br>[!MVVM优点]:<br>实现的是业务逻辑组件的重用，使开发更高效，结构更清晰，增加代码的复用性。</li></ul></li></ul><h2 id="vue-js核心？"><a href="#vue-js核心？" class="headerlink" title="vue.js核心？"></a>vue.js核心？</h2><ul><li>官方定义：通过尽可能简单的API实现响应的数据绑定和组合的视图组件</li></ul><h2 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h2><ul><li>传统js手动改变DOM来改变视图，vue.js只需要改变数据就会自动改变视图，就是MVVM思想的实现</li></ul><h2 id="视图组件化"><a href="#视图组件化" class="headerlink" title="视图组件化"></a>视图组件化</h2><ul><li>定义：把网页拆分一个个区块，每个区块我们可以看成一个组件。网页由多个组件拼接或嵌套组成</li></ul><h2 id="vue的特点"><a href="#vue的特点" class="headerlink" title="vue的特点"></a>vue的特点</h2><ul><li>响应式编程：编写代码基于对变化的反应</li><li>组件化</li></ul><h3 id="组件和模块"><a href="#组件和模块" class="headerlink" title="组件和模块"></a>组件和模块</h3><ul><li>组件：把重复代码提取出来合并成为一个组件，组件最重要的是复用，位于框架最底层，其他功能依赖于组件，可供不同功能使用，独立性强</li><li>模块：分属同一功能&#x2F;业务的代码进行隔离（分装）成独立的模块，可以独立运行，以页面、功能或其他不同粒度划分程度不同的模块。位于业务框架层，模块间通过接口调用，目的是降低模块间的耦合，由之前的主应用与模块耦合，变为主应用与接口耦合，接口与模块耦合<br>[比喻]模块就像有多个USB插口的充电宝，可以和多部手机充电，接口可以随意插拔。复用性很强，可以独立管理。</li><li>组件化模块化区别？<ul><li><ol><li>组件相当于库，把一些能在项目里或者不同类型项目中可复用的代码进行封装</li></ol></li><li><ol start="2"><li>而模块相当于业务逻辑模块，把同一类型项目里的功能逻辑进行需求性的封装</li></ol></li></ul></li><li>为什么要用组件和模块<ul><li>开发和调式效率高</li><li>可维护性强</li><li>避免阻断</li><li>版本管理更容易</li></ul></li></ul><h2 id="vue的优缺点？"><a href="#vue的优缺点？" class="headerlink" title="vue的优缺点？"></a>vue的优缺点？</h2><ul><li>优点：轻量级框架，数据双向绑定，组件化，虚拟dom，运行速度快</li><li>缺点：<ul><li>不支持ie678</li><li>生态环境差不如angular和react</li><li>社区不大</li><li>无高阶书籍</li><li>首屏加载速度满，加载时，将所有的css,js文件进行加载</li></ul></li></ul><h3 id="BTW——首屏加载慢解决方式"><a href="#BTW——首屏加载慢解决方式" class="headerlink" title="BTW——首屏加载慢解决方式"></a>BTW——首屏加载慢解决方式</h3><ul><li>减少入口文件体积</li><li>UI框架按需引入</li><li>静态资源本地缓存</li><li>图片资源压缩</li><li>组件重复打包</li><li>使用SSR（通过对文件、目录、进程、注册表和服务的强制访问控制，有效的制约和分散了原有系统管理员的权限）</li></ul><h3 id="BTW——粒度和耦合"><a href="#BTW——粒度和耦合" class="headerlink" title="BTW——粒度和耦合"></a>BTW——粒度和耦合</h3><ul><li>粒度：计算机中常指系统内存扩展增量的最小值。粒度问题是设计数据仓库的一个最重要方面。粒度是指数据仓库的数据单位中保存数据的细化或综合程度的级别。细化程度越高，粒度级就越小；相反，细化程度越低，粒度级就越大。数据的粒度一直是一个设计问题。</li><li>耦合：两个东西通过某种作用连接在了一起</li></ul><h1 id="vue核心的底层原理"><a href="#vue核心的底层原理" class="headerlink" title="vue核心的底层原理"></a>vue核心的底层原理</h1><ul><li><p>Object.defineProperty数据劫持的API</p></li><li><p>Object.defineProperty定义新属性或修改原有的属性，vue的数据双向绑定原理就是Object.defineProperty，里面定义了setter和getter方法，通过观察者模式(发布订阅模式)来监听数据变化，从而做相应的逻辑处理</p></li><li><p>监听对象属性变化，只关心数据不关心视图</p></li><li><p>三个参数- 三个参数Object.defineProperty(object,propName,descriptor)</p><ul><li>object 对象&#x3D;&gt;给谁加</li><li>propName 属性名&#x3D;&gt;需要加的属性的名字[类型:String]</li><li>descriptor 属性描述&#x3D;&gt;加的这个属性有什么特性[类型：Object]</li><li>方法就是直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象</li></ul></li><li><p>属性描述符</p><ul><li>configurable: true 配置可删除，默认false<ul><li>两个作用：<ol><li>目标属性是否可以使用delete删除</li><li>目标属性是否可以再次设置特性</li></ol></li></ul></li><li>writable：true 配置可修改，默认false</li><li>enumerable:true 可枚举，使用(for…in或Object,keys())默认false</li><li>value属性对应的值，可以是任意类型的值，默认undefined</li><li>缺点：数组的长度</li></ul></li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// writable应用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Person</span> = &#123;&#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Person</span>,<span class="string">&#x27;name&#x27;</span>,&#123;<span class="attr">value</span>:<span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">        <span class="comment">// writable:true // 加上这个就可以输出&#123;name:&#x27;Rose&#x27;&#125;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>) <span class="comment">// &#123;name:&#x27;Jack&#x27;&#125;</span></span><br><span class="line">    <span class="title class_">Person</span>.<span class="property">name</span> = <span class="string">&#x27;Rose&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>) <span class="comment">//undefined,因为writable默认false</span></span><br><span class="line"><span class="comment">// enumerable应用</span></span><br><span class="line">    <span class="keyword">var</span> user=&#123;<span class="attr">name</span>:<span class="string">&#x27;小五&#x27;</span>,<span class="attr">age</span>:<span class="string">&#x27;24&#x27;</span>&#125;;</span><br><span class="line">    <span class="comment">// es6</span></span><br><span class="line">        <span class="keyword">var</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(user)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(keys) <span class="comment">// [&#x27;name&#x27;,&#x27;age&#x27;]</span></span><br><span class="line">    <span class="comment">// es5</span></span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">Key</span> = []</span><br><span class="line">        <span class="keyword">for</span>(key <span class="keyword">in</span> user) &#123;</span><br><span class="line">            <span class="title class_">Key</span>.<span class="title function_">push</span>(<span class="title class_">Key</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Key</span>) <span class="comment">// [&#x27;name&#x27;,&#x27;age&#x27;]</span></span><br><span class="line"><span class="comment">// configurable应用</span></span><br><span class="line">    <span class="keyword">var</span> human=&#123;<span class="attr">name</span>:<span class="string">&#x27;李白&#x27;</span>,<span class="attr">age</span>:<span class="string">&#x27;不详&#x27;</span>&#125;；</span><br><span class="line">    <span class="comment">// 定义一个性别，不可被删除和重新定义特性</span></span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(human,<span class="string">&#x27;gender&#x27;</span>,&#123;</span><br><span class="line">            <span class="attr">value</span>:<span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">            <span class="attr">enumerable</span>:<span class="literal">true</span>,</span><br><span class="line">            <span class="attr">configurable</span>:<span class="literal">false</span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="comment">// 删除一下</span></span><br><span class="line">        <span class="keyword">delete</span> human.<span class="property">gender</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(human)<span class="comment">//&#123;name:&quot;李白&quot;,age:&quot;不详&quot;,gender:&quot;男&quot;&#125; 并没有删除</span></span><br><span class="line">    <span class="comment">// 重新定义特性</span></span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(human,<span class="string">&#x27;gender&#x27;</span>,&#123;</span><br><span class="line">            <span class="attr">value</span>:<span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">            <span class="attr">enumerable</span>:<span class="literal">true</span>,</span><br><span class="line">            <span class="attr">configurable</span>:<span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">delete</span> human.<span class="property">gender</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(human) <span class="comment">// &#123;name:&quot;李白&quot;,age:&quot;不详&quot;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>存取描述符<br>  get<br>  一个给属性提供 getter 的方法，如果没有getter则为undefined。该方法返回值被用作属性值。默认为undefined。getter就是获取属性值<br>  set<br>  一个给属性提供 setter 的方法，如果没有setter则为undefined。该方法将接收唯一参数，并将该参数的新值分配给属性。默认为undefined。setter就是设置属性值<br>[!注意]：1. 当使用getter或setter方法，不允许使用writable和value这两个属性<br>  2. get或set不是必须成对出现，任写其一就行。如果不设置方法，get和set默认undefined</li></ul><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> username = &#123;<span class="attr">name</span>:<span class="string">&quot;不想起名了&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">12</span></span><br><span class="line"><span class="comment">// 定义一个age获取值时返回定义好的变量</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(username,<span class="string">&#x27;age&#x27;</span>,&#123;</span><br><span class="line">        <span class="attr">get</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(username.<span class="property">age</span>);<span class="comment">//12</span></span><br><span class="line"><span class="comment">// 定义一个age获取值时返回定义好的变量num</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(username,<span class="string">&#x27;age&#x27;</span>,&#123;</span><br><span class="line">        <span class="attr">get</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attr">set</span>:<span class="keyword">function</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            num = newVal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(username.<span class="property">age</span>);<span class="comment">// 12</span></span><br><span class="line">    username.<span class="property">age</span> = <span class="number">145</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(username.<span class="property">age</span>); <span class="comment">// 145</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 145</span></span><br></pre></td></tr></table></figure><ul><li>兼容性：IE8以下不行</li><li>使用Object.defineProperty的优点<ol><li>减少代码（少了dom,不需要写很多dom）</li><li>开发速度快</li></ol></li></ul><h3 id="BTW——数据劫持"><a href="#BTW——数据劫持" class="headerlink" title="BTW——数据劫持"></a>BTW——数据劫持</h3><ul><li>定义：修改或访问对象的属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果</li></ul><h1 id="vue环境搭建"><a href="#vue环境搭建" class="headerlink" title="vue环境搭建"></a>vue环境搭建</h1><ul><li>环境需要:nodejs 检测cmd:node-v</li><li>安装全局脚手架:<code>npm i -g @vue/cli</code> 检测：vue-V<code>yarn global add @vue/cli</code></li><li>脚手架网站:cli.vuejs.org</li><li>vue官网: vuejs.org</li></ul><h2 id="创建vue项目"><a href="#创建vue项目" class="headerlink" title="创建vue项目"></a>创建vue项目</h2><p>【注意】:项目名称不能是中文，不能是大写字母，不能用vue做名字</p><h3 id="命令运行方式"><a href="#命令运行方式" class="headerlink" title="命令运行方式"></a>命令运行方式</h3><p><code>vue create name</code></p><h3 id="gui图形化方式"><a href="#gui图形化方式" class="headerlink" title="gui图形化方式"></a>gui图形化方式</h3><p><code>vue ui</code></p><h2 id="vue脚手架"><a href="#vue脚手架" class="headerlink" title="vue脚手架"></a>vue脚手架</h2><ul><li>定义:vue的cli脚手架底层是webpack,也就是基于webpack封装的<br>  [官网]（<a href="http://cli.vuejs.org)/">http://cli.vuejs.org）</a></li></ul><h2 id="BTW——是脚手架？"><a href="#BTW——是脚手架？" class="headerlink" title="BTW——是脚手架？"></a>BTW——是脚手架？</h2><ol><li>什么是脚手架？<ul><li>构建基于数据库的应用，进行增、删、改、查数据库的操作</li></ul></li><li>Vue-CLi是什么？<ul><li>是vuejs脚手架工具，就是自动帮你生成好项目目录，配置好webpack，以及各种依赖包工具</li><li>为什么要用？可以帮助你快速开启一个vue项目，给你一套文件结构，包含基础的依赖库，只需要npm install 一下就可以安装，不需要为编译或其他琐碎事而浪费时间，而且不会限制到你发挥</li></ul></li></ol><h2 id="脚手架配置"><a href="#脚手架配置" class="headerlink" title="脚手架配置"></a>脚手架配置</h2><ul><li>vue.config.js文件是脚手架配置文件，该文件必须放在项目的根目录里</li></ul><h3 id="请求代理【跨域方案】"><a href="#请求代理【跨域方案】" class="headerlink" title="请求代理【跨域方案】"></a>请求代理【跨域方案】</h3><p>脚手架-&gt;webpack-&gt;nodejs【后端】<br>使用后端转发请求<br>【注意】只能在开发环境中使用<br>【使用场景】在公司里和后端的测试接口进行接口调式使用</p><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">    <span class="attr">devServer</span>:&#123;</span><br><span class="line">        <span class="comment">// 浏览器自动打开</span></span><br><span class="line">        <span class="attr">open</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 代理</span></span><br><span class="line">        <span class="attr">proxy</span>:&#123;</span><br><span class="line">            <span class="string">&quot;/api&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">target</span>:<span class="string">&quot;http://xx.com&quot;</span>,</span><br><span class="line">                <span class="attr">changeOrigin</span>:<span class="literal">true</span>,</span><br><span class="line">                <span class="attr">pathRewrite</span>:&#123;</span><br><span class="line">                    <span class="string">&quot;^/api&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关闭源码映射【性能优化】"><a href="#关闭源码映射【性能优化】" class="headerlink" title="关闭源码映射【性能优化】"></a>关闭源码映射【性能优化】</h3><ul><li>productionSourceMap:false<br>  打包的时候，每一个js文件对应生成一个map源码映射文件，它在生产环境中时没有用的。它会增加打包时间，浪费磁盘空间，以及容易造成代码泄漏等问题，因此需要在生产环境中关闭，只允许开发环境中开启</li></ul><h3 id="关闭eslint代码校验"><a href="#关闭eslint代码校验" class="headerlink" title="关闭eslint代码校验"></a>关闭eslint代码校验</h3><ul><li>lintOnSave:false</li></ul><h2 id="AIA：脚手架配置有哪些？"><a href="#AIA：脚手架配置有哪些？" class="headerlink" title="AIA：脚手架配置有哪些？"></a>AIA：脚手架配置有哪些？</h2><ol><li>代码校验</li><li>代码映射的开启与关闭</li><li>请求代理vue.config.js</li></ol><h1 id="vue项目结构"><a href="#vue项目结构" class="headerlink" title="vue项目结构"></a>vue项目结构</h1><h2 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h2><ul><li>项目根目录里有一个package.json文件，该文件有一个script对象，里面就是自定义运行命令。（是这三个里唯一一个可以删的）</li><li>serve开发环境，写代码时的环境</li><li>build生产环境，打包发布时的环境</li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul><li><ul><li>node_modules它是项目运行时必须依赖</li></ul></li><li>public公共目录，存放着唯一的html模板</li><li>src【核心-源码】项目所有代码</li><li>.gitignore过滤掉git仓库里不需要的文件清单</li><li>babel.config.js把es6转成es5</li><li>package.lock.json(可以删但一般留着)，锁定依赖版本号</li><li>package.json【核心】依赖包管理文件</li><li>README.md说明书</li></ul><h3 id="src源码结构"><a href="#src源码结构" class="headerlink" title="src源码结构"></a>src源码结构</h3><ul><li>assets存放静态资源：图片，css,js脚本</li><li>component放组件</li><li>App.vue根组件，第一个被加载的组件</li><li>main.js入口文件，第一个被执行的文件</li></ul><h2 id="模块化开发【vue核心亮点】"><a href="#模块化开发【vue核心亮点】" class="headerlink" title="模块化开发【vue核心亮点】"></a>模块化开发【vue核心亮点】</h2><p>把一切重复使用的资源，无论是图片，样式还是js代码抽离出来，作为单独的’模块’进行复用</p><ul><li>模块包含：vue 组件，图片，js 脚本，css 样式，字体等都可以是模块。</li></ul><h2 id="vue里的模块化组件开发"><a href="#vue里的模块化组件开发" class="headerlink" title="vue里的模块化组件开发"></a>vue里的模块化组件开发</h2><ul><li><ol><li>组件必须使用import引入到当前组件</li></ol></li><li><ol start="2"><li>当前组件的components必须挂载引入的组件</li></ol></li><li><ol start="3"><li>在当前组件的template里用标签的形式使用挂载的组件</li></ol></li></ul><h1 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h1><ul><li>渲染文本</li><li>写在两个大括号中间</li></ul><h2 id="插值语法可以写哪些值"><a href="#插值语法可以写哪些值" class="headerlink" title="插值语法可以写哪些值"></a>插值语法可以写哪些值</h2><ul><li>对象、字符串、数字、数组、布尔值、三元表达式、自执行函数等，凡是具有返回值的都可以，全部变成文本渲染出来</li></ul><h2 id="BTW——自执行函数和快速删除文件"><a href="#BTW——自执行函数和快速删除文件" class="headerlink" title="BTW——自执行函数和快速删除文件"></a>BTW——自执行函数和快速删除文件</h2><h4 id="自执行函数后面-（）"><a href="#自执行函数后面-（）" class="headerlink" title="自执行函数后面+（）"></a>自执行函数后面+（）</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> <span class="number">1000</span>()&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么用自执行函数而不是函数"><a href="#为什么用自执行函数而不是函数" class="headerlink" title="为什么用自执行函数而不是函数"></a>为什么用自执行函数而不是函数</h2><p>用函数也可以，只不过返回时function(){return 1000},而不是1000</p><h2 id="插值语法的作用"><a href="#插值语法的作用" class="headerlink" title="插值语法的作用"></a>插值语法的作用</h2><ol><li>四则运算 100+(200*300)&#x2F;2</li><li>插值里存放变量 (详情请找baseVue.html)</li></ol><h4 id="npkill和rimraf快速删除node-modules包"><a href="#npkill和rimraf快速删除node-modules包" class="headerlink" title="npkill和rimraf快速删除node_modules包"></a>npkill和rimraf快速删除node_modules包</h4><ol><li>全局安装npm i -g npkill</li><li>进入想清理的文件夹</li><li>cd文件路径</li><li>输入npkill</li><li>会自动查找文件中node_modules</li><li>光标上下移动来选择要清理的目录，释放宝贵的空间</li><li>按空格删除</li></ol><h1 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h1><h2 id="set添加或修改对象和数组"><a href="#set添加或修改对象和数组" class="headerlink" title="$set添加或修改对象和数组"></a><code>$set</code>添加或修改对象和数组</h2><p>添加&#x2F;修改对象的属性 <code>$set(obj,&#39;name&#39;,1)</code><br>添加或修改数组成员<code>$set(arr,index,val)</code></p><h2 id="delete删除对象和数组"><a href="#delete删除对象和数组" class="headerlink" title="$delete删除对象和数组"></a><code>$delete</code>删除对象和数组</h2><ul><li>删除对象属性<code>$delete(obj,name)</code></li><li>删除数组成员<code>$delete(arr,index)</code></li></ul><h2 id="emit派发一个动作向上级通信"><a href="#emit派发一个动作向上级通信" class="headerlink" title="$emit派发一个动作向上级通信"></a><code>$emit</code>派发一个动作向上级通信</h2><h2 id="mount手动挂载方法"><a href="#mount手动挂载方法" class="headerlink" title="$mount手动挂载方法"></a><code>$mount</code>手动挂载方法</h2><h1 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h1><ul><li>props接收上游绑定的属性</li></ul><h2 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h2><ul><li>数组：<code>[&#39;list&#39;]</code></li><li>对象:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>:&#123;</span><br><span class="line">    <span class="attr">list</span>:&#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="title class_">Array</span>,</span><br><span class="line">        <span class="comment">// 针对数组或对象需要函数</span></span><br><span class="line">        <span class="attr">default</span>:<span class="function">() =&gt;</span> [] <span class="comment">//default是没有任何值的时候默认的值，保证你需要该属性的时候不是undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>父组件要正向地向子组件传递数据或参数，子组件收到后，根据传递过来的数据不同，渲染不同的页面内容，或者执行操作。这个正向传递数据的过程是通过props来实现的。子组件使用props来声明需要从父组件接收的数据<br>[!注意]：</li></ul><ol><li><p>不应该在一个子组件内部改变 prop，这样会破坏单向的数据绑定，导致数据流难以理解。如果有这样的需要，可以通过 data 属性接收或使用 computed 属性进行转换。</p></li><li><p>如果 props 传递的是引用类型(对象或者数组)，在子组件中改变这个对象或数组，父组件的状态会也会做相应的更新，利用这一点就能够实现父子组件数据的“双向绑定”，虽然这样实现能够节省代码，但会牺牲数据流向的简洁性，令人难以理解，最好不要这样去做。</p></li><li><p>prop只读不可修改</p></li><li><p>想要实现父子组件的数据“双向绑定”，可以使用 v-model 或 .sync</p></li></ol><h2 id="两种常见的试图变更一个prop的情形"><a href="#两种常见的试图变更一个prop的情形" class="headerlink" title="两种常见的试图变更一个prop的情形"></a>两种常见的试图变更一个prop的情形</h2><ul><li>这个prop用来传递一个初始值这个子组件接下来希望将其作为一个本地的prop数据来使用。在这种情况下，最好定义一个本地的data property并将这个prop用作其初始值</li><li>这个prop以一种原始的值传入且需要转换。在这种情况下，最好使用这个prop的值来定义一个计算属性</li></ul><h1 id="scss动态生成类名（待写11-26scss动态生成类名-vue）"><a href="#scss动态生成类名（待写11-26scss动态生成类名-vue）" class="headerlink" title="scss动态生成类名（待写11.26scss动态生成类名.vue）"></a>scss动态生成类名（待写11.26scss动态生成类名.vue）</h1><p>例如：有一p标签，起一个class名为m-l-10<br>     <!-- 在export default中     @for $name from 1 through 100 {        .m-l-#{$name} {            margin-left:$name+px        }     } --></p><h1 id="v-指令"><a href="#v-指令" class="headerlink" title="v-指令"></a>v-指令</h1><h2 id="什么是指令？"><a href="#什么是指令？" class="headerlink" title="什么是指令？"></a>什么是指令？</h2><p>是带有v-前缀的特殊属性，通过属性来操作元素</p><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><ul><li>因为vue是单向数据流，所以v-model在input上只是语法糖而已<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一行代码是第二行的语法糖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;sth&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;sth&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;sth=$event.target.value&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 理解上述代码</span></span><br><span class="line"><span class="comment">    input本身有个oninput事件，这是h5新增，类似onchange,每当输入框内容发生变化的时候，就会触发oninput，把最新的value传递给sth</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 所以</span></span><br><span class="line"><span class="comment">在给&lt;input/&gt;元素添加v-model属性时，默认会把value作为元素的属性，然后把&#x27;input&#x27;事件作为实时传递value的触发事件 --&gt;</span></span><br></pre></td></tr></table></figure></li><li>用在组件上<br> 给组件加v-model，默认会把value作为组件的属性，然后把’input’值作为给组件绑定事件的事件名</li></ul><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">Cur-input</span> <span class="attr">v-model</span>=<span class="string">&quot;price&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Cur-input</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&quot;input&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;value&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;$emit(&#x27;input&#x27;)$event.target.value&quot;</span>&gt;</span></span><br><span class="line">export default &#123;</span><br><span class="line">    data:&#123;price:100&#125;,</span><br><span class="line">    props:[&#x27;value&#x27;]<span class="comment">&lt;!-- 这里为什么用value？--&gt;</span></span><br><span class="line">&#125;</span><br><span class="line">【问题解答】：</span><br><span class="line"><span class="tag">&lt;<span class="name">Cur-input</span> <span class="attr">:value</span>=<span class="string">&quot;price&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;price=arguments[0]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Cur-input</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-model缺点及解决办法"><a href="#v-model缺点及解决办法" class="headerlink" title="v-model缺点及解决办法"></a>v-model缺点及解决办法</h3><ul><li>在创建类似复选框或单选框这种常见的组件时，v-model就不好用了。因为不需要value属性而是checked属性，并且当你点击这个单选框的时候不会触发oninput事件，它只会触发onchange事件。<br>[解决办法]:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- input上 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">:checked</span>=<span class="string">&quot;status&quot;</span> @<span class="attr">change</span>=<span class="string">&quot;status=$event.target.checked&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 组件上 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> @<span class="attr">change</span>=<span class="string">&quot;$emit(&#x27;suibian&#x27;,$event.target.checked)&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:checked</span>=<span class="string">&quot;value&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    props:[&#x27;checked&#x27;]</span><br></pre></td></tr></table></figure><br><br>[!注意]v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值而总是将 Vue 实例的数据作为数据来源。应通过 JavaScript 在组件的 data 选项中声明初始值。</li></ul><h3 id="表单的使用——专用指令-v-model"><a href="#表单的使用——专用指令-v-model" class="headerlink" title="表单的使用——专用指令:v-model"></a>表单的使用——专用指令:v-model</h3><p>v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 value 属性和 input 事件；（默认）</li><li>radio单选框<ul><li>checkbox 和 radio 使用 checked 属性和 change 事件；(单个复选框，绑定到布尔值，多个复选框，绑定到同一个数组：)</li><li>语法：<code>&lt;input type=&#39;radio&#39; v-model=&#39;radio&#39; value=&#39;1&#39;/&gt;</code></li></ul></li><li>select下拉菜单<ul><li>select 字段将 value 作为 prop 并将 change 作为事件。</li><li>语法<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&#x27;selected&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&#x27;1000&#x27;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="BTW——语法糖-onchange-input"><a href="#BTW——语法糖-onchange-input" class="headerlink" title="BTW——语法糖 onchange @input"></a>BTW——语法糖 onchange @input</h2><ol><li>语法糖：用更简练的言语表达较复杂的含义</li><li>onchange事件<ul><li>定义：事件会在域的内容改变时发生</li><li>可用于单选框与复选框改变后触发的事件</li><li>语法:input type&#x3D;”text” onchange&#x3D;”myFunction()</li></ul></li><li>@input一般用于监听事件，只要输入的值变化了就会触发input，而@click是事件触发事件</li></ol><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><ul><li>控制元素显示与隐藏，但是元素的dom节点一直存在页面中的，他的底层原理是控制css的display属性</li><li>当频繁切换元素显示隐藏的时候，优先使用v-show<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 条件渲染v-show</span></span><br><span class="line"><span class="comment">    控制css display样式，dom节点是存在于页面中的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> @<span class="attr">click</span>=<span class="string">&quot;flag()&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;see&quot;</span>&gt;</span>我可以被显示吗<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">see</span>:<span class="literal">false</span></span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">flag</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.<span class="property">see</span> =! <span class="variable language_">this</span>.<span class="property">see</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><ul><li>它是控制元素的加载(渲染)和销毁，底层是删除或者加载出dom</li><li>它还有v-else-if和v-else但是后面两个不能单独使用</li><li>它是条件控制语句，它只要有一个符合条件，则后面的v-else-if和v-else就不执行判断</li><li>适合用于多条件判断渲染<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 多条件切换的时候使用 v-if --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;index=1&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;index=2&quot;</span>&gt;</span>新闻<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;index=3&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 面板 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;index==1&quot;</span>&gt;</span>我是首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else-if</span>=<span class="string">&quot;index==2&quot;</span>&gt;</span>我是新闻<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>我是关于<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//1.首页 2.新闻 3.关于</span></span></span><br><span class="line"><span class="language-javascript">                <span class="attr">index</span>:<span class="number">1</span>,</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><ul><li>定义：绑定属性的，可以绑定原生属性和自定义属性</li><li>缩写<code>:</code></li><li>修饰符<ul><li>prop把标签上的属性隐藏</li><li>sync把数据变成为双向绑定(与v-model类似，v-model只能用于对象否则会警告，这个可以解决基本数据类型不是双向绑定问题)</li></ul></li></ul> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-bind:title</span>=<span class="string">&quot;doc.title&quot;</span> <span class="attr">v-on:update:title</span>=<span class="string">&quot;doc.title=$event&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 上述代码用.sync可以写为 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-bind:title.sync</span>=<span class="string">&quot;doc.title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在子组件中，可以通过下面代码实现对prop重新赋值 --&gt;</span></span><br><span class="line">this.$emit(&#x27;update:title&#x27;,newTitle)</span><br></pre></td></tr></table></figure><p>[AIA]</p><ul><li>父组件使用 sync 修饰绑定的属性<br>  <code>v-bind:prop.sync=data</code></li><li>子组件使用固定语法<br>  <code>$emit(&#39;update:prop&#39;,value)</code></li></ul><h3 id="BTW——-emit-mount"><a href="#BTW——-emit-mount" class="headerlink" title="BTW——$emit $mount"></a>BTW——$emit $mount</h3><ul><li><p><code>$emit</code>  派发一个动作向上级通信</p></li><li><p><code>$mount</code> 手动挂载方法</p></li><li><p>语法</p><ul><li>绑定样式  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;&#123;name:true|false&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>绑定自定义  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Son</span> <span class="attr">:data</span>=<span class="string">&quot;data&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Son</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>样例</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- v-bind:绑定属性的指令 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;logo&quot;</span> <span class="attr">kkk</span>=<span class="string">&quot;hahah&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">            img标签?dom元素=dom对象</span></span><br><span class="line"><span class="comment">            src 对于img原始的属性</span></span><br><span class="line"><span class="comment">            kkk 对于img，自定义属性</span></span><br><span class="line"><span class="comment">            v-bind:既可以绑定原始和自定义属性     </span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 绑定背景图 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height:500px;border:1px solid red&quot;</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;&#123;background:`url($&#123;logo&#125;)`&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 绑定class类名</span></span><br><span class="line"><span class="comment">        v-on:click=&#x27;回调函数/表达式&#x27; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-bind:class</span>=<span class="string">&#x27;&#123;active:n&#125;&#x27;</span> <span class="attr">v-on:click</span>=<span class="string">&#x27;n=n ? false :1&#x27;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 用对象包着是因为，对象里可以绑定很多class名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//引入图片</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> src <span class="keyword">from</span> <span class="string">&#x27;../../assets/logo.png&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// console.log(src)</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//若引入很多张图片 脚手架-&gt;基于webpack-&gt;基于nodejs 所以可以使用nodejs里的require</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> img= <span class="built_in">require</span>(<span class="string">&#x27;../../assets/logo.png&#x27;</span>);<span class="comment">// 直接在export中输出require(&#x27;../../assets/logo.png&#x27;)不用写这个</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 任何文件都是模块</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">n</span>:<span class="literal">false</span>,<span class="comment">//true是绑定，false是不要</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// logo:&#x27;../../assets/logo.pn&#x27;,这个卸载这里出不来放到import中，这里logosrc</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">logo</span>:src,<span class="comment">// 对应import</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">logo</span>:<span class="built_in">require</span>(<span class="string">&#x27;../../assets/logo.pn&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 高亮颜色 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.active</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>:red;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>:white;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><ul><li>定义：事件绑定指令，可以绑定原生事件和自定义事件</li><li>缩写：<code>@</code></li><li>语法：<code>v-on:click=&#39;callBack&#39;</code></li><li>修饰符：<ul><li>.stop 清除事件冒泡</li><li>.prevent 阻止默认行为</li><li>.once 绑定一次函数</li><li>.native 绑定原始事件</li><li>.passive 告诉浏览器不想阻止默认行为</li></ul></li><li>event事件对象<ul><li>target 事件触发的元素</li><li>currentTarget 事件绑定的元素</li></ul></li></ul><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><ul><li>由程序决定触发时机的自定义事件</li><li>语法:绑定：<code>@myEvent=&#39;callBack&#39;</code><br>调用：<code>$emit(&#39;callBack&#39;,参数)</code></li><li>应用场景：父子组件通信的时候</li></ul><h2 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h2><ul><li>底层是innerText</li><li>定义：渲染文本内容，无论写入什么值，最后都被渲染成文本内容</li><li>和插值<code>&#123;&#123;&#125;&#125;</code>基本一致</li><li>为什么有v-text还要有插值语法？<br>v-text覆盖内容，插值语法就是个占位符，用插值偏多</li></ul><h2 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h2><ul><li>定义：用于渲染dom片段的</li><li>底层：innerHTML<br>二者区别：v-html可以转义标签和渲染数据，v-text不能转义标签只能渲染数据<br>  v-html 你好<br>  v-text $lth2$gt你好$lt&#x2F;h2$gt</li></ul><h2 id="v-for循环渲染"><a href="#v-for循环渲染" class="headerlink" title="v-for循环渲染"></a>v-for循环渲染</h2><ul><li>基础语法:<code>v-for=&#39;val in data&#39; key=&#39;val&#39;</code></li><li>获取下标:<code>v-for=&#39;(val,index) in data&#39; :key=&#39;index&#39;</code></li><li>遍历对象：<code>v-for=(val,key,index) in obj</code></li><li>[!注意]key一定不可以是随机数，时间戳，因为值不固定，随时发生改变，key的值必须唯一。随机数时间戳不固定，刷新一次改变一次</li><li>data:对象，数组，数字，字符串</li><li>key&#x3D;’值必须唯一’当前元素的身份，标识，用来优化diff算法进行dom修改</li><li>虚拟dom和diff算法<ul><li>虚拟dom是js动态生成的，是js根据算法得出的</li><li>diff算法，执行规则：同层对比，新旧dom对比，当发现有不同之处，直接用新的dom替换旧的dom部分，diff算法超级快</li></ul></li></ul><h2 id="v-slot-详情搜索插槽"><a href="#v-slot-详情搜索插槽" class="headerlink" title="v-slot(详情搜索插槽)"></a>v-slot(详情搜索插槽)</h2><ul><li>绑定插槽的指令</li><li>作用域插槽、具名插槽和默认插槽</li><li>缩写：<code>#</code></li></ul><h2 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h2><p>永远只显示第一次渲染的值，让数据失去双向响应。它会让被绑定的元素不再进入diff对比，不更新。从而节省了虚拟dom的计算</p><h2 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h2><p>原格式输出内容，不会让元素内的内容解析</p><h2 id="v-clock"><a href="#v-clock" class="headerlink" title="v-clock"></a>v-clock</h2><p>防止插值语法的闪烁问题，插值里的数据如果默认是空的，需要等接口返回才显示的话，页面内容的高随着内容撑开导致页面抖动</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-clock</span>&gt;</span>&#123;message&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-attr">[v-clock]</span> &#123;<span class="attribute">display</span>:none;&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>广义：事物发展的阶段</li><li>具体例子：人的生老病死</li><li>页面加载的过程：初始化，渲染，更新，销毁</li><li>官方定义：钩子函数(生命周期就等于钩子函数)</li></ul><h2 id="页面加载的过程：初始化，渲染，更新，销毁"><a href="#页面加载的过程：初始化，渲染，更新，销毁" class="headerlink" title="页面加载的过程：初始化，渲染，更新，销毁"></a>页面加载的过程：初始化，渲染，更新，销毁</h2><pre><code>诞生：入口函数，当页面完全加载出来，才执行    window.onload去世：当页面被关闭的时候执行，卸载    window.onunload更新：重新加载，页面要发生变化    window.onreload</code></pre><h2 id="生命周期作用是什么？"><a href="#生命周期作用是什么？" class="headerlink" title="生命周期作用是什么？"></a>生命周期作用是什么？</h2><p>Vue 所有的功能的实现都是围绕其生命周期进行的，在生命周期的不同阶段调用对应的钩子函数可以实现组件数据管理和DOM渲染两大重要功能。</p><h2 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h2><h3 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h3><p>预加载资源，骨架屏，上传日志等操作</p><h4 id="创建前-beforeCreate"><a href="#创建前-beforeCreate" class="headerlink" title="创建前 beforeCreate"></a>创建前 beforeCreate</h4><ul><li>vue对象创建之前触发的函数</li><li>此阶段为实例化初始后，this指向创建的实例，数据观察，数据监听事件机制都未形成，不能获dom节点。data，computed，watch，methods上的方法和数据都不能访问</li><li>因为data和methods数据都还未初始化</li></ul><h4 id="创建后-created"><a href="#创建后-created" class="headerlink" title="创建后 created"></a>创建后 created</h4><ul><li>vue对象创建完成触发的函数</li><li>实例初始化之后，data，props，computed导入完成</li><li>要调用methods方法，或者操作data的数据最早只能在created中操作</li><li>可以访问watch、methods、computed、data上的数据和方法</li></ul><h3 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h3><!-- 挂载是眼睛可以看见了，就代表已经挂载 --><h4 id="挂载前-beforeMount"><a href="#挂载前-beforeMount" class="headerlink" title="挂载前 beforeMount"></a>挂载前 beforeMount</h4><ul><li>vue对象开始挂载数据的时候触发的函数</li><li>这个阶段是过渡性的，一般一个项目只能用到一两次。</li></ul><h4 id="挂载后-mounted"><a href="#挂载后-mounted" class="headerlink" title="挂载后 mounted"></a>挂载后 mounted</h4><ul><li>vue对象挂载完成的时候触发的函数</li><li>完成创建vm.$el，和双向绑定只要执行完mounted,就表示整个Vue实例已经初始化完成了，此时组件已经脱离里了创建阶段， 进入到了运行阶段。</li><li>这个时候dom在页面呈现了，你可以获取dom，一般用于ajax自动发起请求数据</li></ul><h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><p>更新前还可以对数据进行二次修改，更新后只能是观察数据变化。当data或者props更新或者上游组件更新的时候触发</p><h4 id="更新前-beforeUpdate"><a href="#更新前-beforeUpdate" class="headerlink" title="更新前 beforeUpdate"></a>更新前 beforeUpdate</h4><ul><li>vue对象中的data数据发生改变之前触发的函数</li><li>当执行beforeUpdate的时候，页面中显示的数据还是旧的，此时date数据是最新的，页面尚未和最新数据数据保持同步。但是DOM中的数据会改变，这是vue双向数据绑定的作用，可在更新前访问现有的DOM，如手动移出添加的事件监听器。</li></ul><h4 id="更新后-updated"><a href="#更新后-updated" class="headerlink" title="更新后 updated"></a>更新后 updated</h4><ul><li>vue对象中的data数据发生改变完成触发的函数</li><li>Updated执行时数据已经保持同步了，都是最新的，完成虚拟DOM的重新渲染和打补丁。</li><li>组件DOM已完成更新，可执行依赖的DOM操作。</li><li>不要在此函数中操作数据（修改属性），否则就会陷入死循环。</li></ul><h4 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h4><p>主要用于销毁常驻内存的垃圾，比如定时器，或者全局变量</p><h4 id="销毁前-beforeDestroy"><a href="#销毁前-beforeDestroy" class="headerlink" title="销毁前 beforeDestroy"></a>销毁前 beforeDestroy</h4><ul><li>vue对象销毁之前触发的函数</li><li>该组件还存在</li><li>当执行beforeDestroy的时候，Vue实例就已经从运行阶段进入到销毁阶段了。实例上的所有date和methods以及过滤器和指令都是处于可用状态，此时还没有真正的执行销毁过程。</li></ul><h4 id="销毁后-destroyed"><a href="#销毁后-destroyed" class="headerlink" title="销毁后 destroyed"></a>销毁后 destroyed</h4><ul><li>vue对象销毁完成触发的函数</li><li>指令解绑和事件解绑以及子组件销毁完毕</li></ul><h4 id="errorCaptured捕获后代组件错误"><a href="#errorCaptured捕获后代组件错误" class="headerlink" title="errorCaptured捕获后代组件错误"></a>errorCaptured捕获后代组件错误</h4><ul><li>当组件发生错误时，会被该函数捕获</li><li>该函数有三个参数，第一个错误本身信息，第二个是发生错误的组件实例对象，第三个是发生错误的触发信息</li><li>该函数如果写return false则阻止错误继续向上传递</li></ul><h1 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h1><ul><li>什么是插槽？<br>vue为组件的封装者提供的能力。允许开发者在封装组件时，把不确定的、希望由用户指定的部分定义为插槽</li><li>更高级的组件复用方式。接收dom片段或内容，加工处理后返回显示</li></ul><h2 id="Vue插槽的作用"><a href="#Vue插槽的作用" class="headerlink" title="Vue插槽的作用"></a>Vue插槽的作用</h2><h3 id="vue插槽是vue中常见的一种组件间的相互通信方式，作用是子组件中某个位置插入父组件的自定义html结构和data数据，在要接收数据的组件页面通过标签来表示。简单来说，就是通过此标签来起到占位的作用，而要插入的内容也会对应到标签所在的位置"><a href="#vue插槽是vue中常见的一种组件间的相互通信方式，作用是子组件中某个位置插入父组件的自定义html结构和data数据，在要接收数据的组件页面通过标签来表示。简单来说，就是通过此标签来起到占位的作用，而要插入的内容也会对应到标签所在的位置" class="headerlink" title="vue插槽是vue中常见的一种组件间的相互通信方式，作用是子组件中某个位置插入父组件的自定义html结构和data数据，在要接收数据的组件页面通过标签来表示。简单来说，就是通过此标签来起到占位的作用，而要插入的内容也会对应到标签所在的位置"></a>vue插槽是vue中常见的一种组件间的相互通信方式，作用是子组件中某个位置插入父组件的自定义html结构和data数据，在要接收数据的组件页面通过<slot></slot>标签来表示。简单来说，就是通过此标签来起到占位的作用，而要插入的内容也会对应到标签所在的位置</h3><h2 id="三种插槽的定义"><a href="#三种插槽的定义" class="headerlink" title="三种插槽的定义"></a>三种插槽的定义</h2><h3 id="默认插槽（匿名插槽）"><a href="#默认插槽（匿名插槽）" class="headerlink" title="默认插槽（匿名插槽）"></a>默认插槽（匿名插槽）</h3><ul><li>定义：默认插槽是将父组件的结构和数据插入子组件中，默认插槽只有一个插入位置，要插入的html结构和data数据必须在父组件中，不过css可以在子组件中</li><li>特点： 父组件决定结构和数据</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">    &lt;template&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">            &#123;/* Child为子组件标签 </span></span><br><span class="line"><span class="language-xml">            插槽内容，可以是template标签也可以是其他标签,比如<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片地址&quot;</span> /&gt;</span>  */&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">template</span>&gt;</span>要插入的html内容<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;/* 插槽位置</span></span><br><span class="line"><span class="language-xml">            插槽通俗的说就是：挖个坑，等组件的使用者进行填充 */&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">slot</span>&gt;</span>这里可以写默认值，当使用者没有传递具体结构时，会显示此内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><ul><li>定义：简单地说就是具有名字的插槽，只是默认插槽只有一个插入位置，具名插槽可以有多个插入位置，根据名字来识别对应的插槽</li><li>特点： 父组件决定结构和数据</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">        &#123;/* Child为子组件标签</span></span><br><span class="line"><span class="language-xml">        插槽内容 */&#125;</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:one</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">testchart</span>&gt;</span><span class="tag">&lt;/<span class="name">testchart</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        //这是为了验证，子组件中的插槽可以填充任何结构的内容，所以在one插槽中插入一个组件</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:two</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            我是要给two插槽的信息</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    <span class="attr">components</span>:&#123;</span><br><span class="line">        testchart,</span><br><span class="line">        child</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;one&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;two&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><ul><li>定义：作用域插槽的data数据固定写在子组件中，数据的html结构根据父组件传入的html结构来决定</li><li>简述： 根据父组件中不同的html结构解析data中的数据</li><li>特点： 子组件决定数据，父组件决定结构</li><li>父组件中的插槽模版template里，其作用域属于插槽组件<br>&lt;slot :自定义name&#x3D;data中的属性或者对象&gt;</slot></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 父组件</span></span><br><span class="line">  &lt;template&gt;</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">          &#123;/* Child为子组件标签 </span></span><br><span class="line"><span class="language-xml">          插槽内容，作用域插槽必须要写template   */&#125;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">&quot;m in data.msg&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;m&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;m in data.msg&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;m&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">label</span> <span class="attr">v-for</span>=<span class="string">&quot;m in data.msg&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;m&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子组件</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;/* 插槽位置 </span></span><br><span class="line"><span class="language-xml">插槽的结构是由使用者决定的 */&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">:msg</span>=<span class="string">&quot;msg&quot;</span>&gt;</span>插槽未被调用时会显示此内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="attr">name</span>: <span class="string">&#x27;Child&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">// 公用数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  <span class="attr">msg</span>: [<span class="string">&quot;火锅&quot;</span>, <span class="string">&quot;红烧肉&quot;</span>, <span class="string">&quot;烤羊腿&quot;</span>]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>父传子：父组件使用v-bind 向插槽组件传参</li><li>子传父：插槽组件在slot组件上使用v-bind 反向传参<br>父组件使用<code>v-slot=&#39;参数&#39;</code> 接收数据<br>[AIA]一句话概括就是v-slot:后边是插槽名称，&#x3D;后边是组件内部绑定作用域值的映射</li></ul><h1 id="vue组件"><a href="#vue组件" class="headerlink" title="vue组件"></a>vue组件</h1><ul><li>凡是以<code>.vue</code>做文件后缀的都是组件</li></ul><h2 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h2><ul><li>作用域只限于当前使用该组件的环境中生效</li></ul><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Com</span> <span class="keyword">from</span> <span class="string">&quot;./Com.vue&quot;</span></span><br><span class="line"><span class="attr">components</span>:&#123;</span><br><span class="line">    <span class="title class_">Com</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="title class_">Com</span>&gt;&lt;/<span class="title class_">Com</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h2><ul><li>该组件生效环境为整个项目，任何组件内使用都可以直接使用该组件，且不用单独导入</li></ul><h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MySon</span> <span class="keyword">from</span> <span class="string">&quot;./MySon.vue&quot;</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;my-son&quot;</span>,<span class="title class_">MySon</span>);</span><br><span class="line"><span class="comment">// 每次只能挂载一个</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="全局组件局部组件对比"><a href="#全局组件局部组件对比" class="headerlink" title="全局组件局部组件对比"></a>全局组件局部组件对比</h2><ol><li>全局组件在使用上比局部组件更简单，更快，更省代码</li><li>全局组件可能会污染全局环境，比如命名重复，被替换覆盖等问题，并且造成代码冗余，后期维护不方便</li><li>所以要合理的使用全局组件，当一个组件被重复使用3次及以上则考虑全局组件</li></ol><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><ul><li>定义：两个组件及以上进行数据交互，叫做组件通信</li><li>分为两类</li></ul><ol><li>父子之间通信</li><li>非父子之间的通信</li></ol><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><ul><li>父组件使用 v-bind 给子组件绑定属性</li><li>子组件使用 <code>$emit</code>接收父组件给的属性</li></ul><h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><ul><li>父组件使用 v-on 给子组件绑定自定义事件函数</li><li>子组件使用 <code>$emit</code>调用父组件传递的函数</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">:msg</span>=<span class="string">&quot;articleList&quot;</span> @<span class="attr">changeMsg</span>=<span class="string">&quot;changeMsg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">&#x27;./child.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">msg</span>:<span class="string">&#x27;巧克力&#x27;</span></span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">changeMsg</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">this</span>.<span class="property">msg</span> = msg</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 这里两个大括号中间放msg --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;change&quot;</span>&gt;</span>改变字符串<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">props</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">msg</span>:<span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">change</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">this</span>.$emit(<span class="string">&#x27;changeMsg&#x27;</span>,<span class="string">&#x27;蛋挞&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="兄弟"><a href="#兄弟" class="headerlink" title="兄弟"></a>兄弟</h3><ul><li>使用父组件作为媒介，父组件充当中转站</li></ul><h3 id="parent和-children-不可控不推荐"><a href="#parent和-children-不可控不推荐" class="headerlink" title="$parent和$children(不可控不推荐)"></a>$parent和$children(不可控不推荐)</h3><ul><li>通过$parent和$children可以访问组件实例，拿到实例代表什么？代表可以访问此组件的所有方法和data</li><li>parent 获取直接父组件实例对象</li><li>children 获取所有渲染的(必须要渲染在template里才能获取到)子组件集合</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 这里两个大括号中间放msg --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeA&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">msg</span>:<span class="string">&#x27;Welcome&#x27;</span></span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">changeA</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 获取到子组件A</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">this</span>.<span class="property">$children</span>[<span class="number">0</span>].<span class="property">messageA</span> = <span class="string">&#x27;this is a new value&#x27;</span></span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>两个大括号中间写messageA<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>获取父组件的值为:两个大括号中间写parentVal<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">messageA</span>:<span class="string">&#x27;this is old&#x27;</span></span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">computed</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">parentVal</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$parent</span>.<span class="property">msg</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>[!注意]：注意边界，如果在#app上拿$parent得到的是new Vue()的实例，在这实例上再拿$parent得到的是undefined，而在最底层的子组件拿$children是个空数组。也要注意得到parent和parent和parent和children的值不一样，$children 的值是数组，而$parent是个对象。<br>$children获取到的实例不保证顺序，因此当有多个子组件时可能获取到的不是自己想要的那一个。当组件嵌套多级时，可能会出现$parent.$parent.$parent…的情况，对于后续维护不友好。</p><ul><li>props $emit 、 $parent $children两种方式用于父子组件之间的通信， 而使用props进行父子组件通信更加普遍，二者皆不能用于非父子组件之间的通信。</li></ul><h3 id="跨层级"><a href="#跨层级" class="headerlink" title="跨层级"></a>跨层级</h3><h4 id="attrs-跨层级传递数据"><a href="#attrs-跨层级传递数据" class="headerlink" title="$attrs 跨层级传递数据"></a><code>$attrs</code> 跨层级传递数据</h4><ul><li>通过v-bind&#x3D;”$attrs”传入内部组件——在创建高级别的组件时非常有用</li><li>$attrs可以收集父组件中的所有传过来的属性除了那些在组件中没有通过props定义的。不包括样式class 和 style。<br>【Tip】什么时候用它以及为什么用它？<br>我们如果使用props的话，最里面的组件想要获取最外层组件的数据，就要通过中间的组件的props来传递，但是这个props对于中间的这个组件没啥用处，它就是做了一个桥梁而已。所以就有了这个$attrs来帮助我们，不必在中间组件中写props就可以让最里面的组件拿到最外面组件传进来的数据。</li><li>具体使用</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//grandfather</span></span><br><span class="line">    <span class="keyword">import</span> father <span class="keyword">from</span> <span class="string">&#x27;./father&#x27;</span></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        <span class="attr">components</span>: &#123;</span><br><span class="line">            father</span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            <span class="attr">time</span>: <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- father --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background: red&quot;</span>&gt;</span></span><br><span class="line">    child in father</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>father age:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 两个大括号包着fatherAge --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">&#x27;./child&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        child</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">fatherAge</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">type</span>: <span class="title class_">Number</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">default</span>: <span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- child --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background: green&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>time: </span><br><span class="line">        <span class="comment">&lt;!-- 双括号中包着childTime --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">childTime</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">type</span>: <span class="title class_">String</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">default</span>: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="listeners跨层级传递事件"><a href="#listeners跨层级传递事件" class="headerlink" title="$listeners跨层级传递事件"></a><code>$listeners</code>跨层级传递事件</h4><p>vue1.0以前，没有vuex，想全局管理共享的数据，需要使用“黑魔法”，单独的new一个vue实例对象，基于该对象做数据通信</p><ul><li>通过v-on&#x3D;”$listeners”传入内部组件时非常有用</li><li>它是一个对象，里面包含了作用在这个组件上的所有监听器</li><li>适用场景<br>用.native修饰符可以把”focus”这个原生事件绑定在这个组件上。如果组件的根元素不能使用focus事件时，这个绑定会失效。<br>比如:input 所以为了在input元素上绑定”focus”这个事件，必须在input上用v-on绑定原生事件<input v-on:input="$emit('input',$event.target.value)"/></li></ul><h3 id="inheritAttr"><a href="#inheritAttr" class="headerlink" title="inheritAttr"></a>inheritAttr</h3><p>默认情况下被父作用域的不被认作props的特性绑定，将会“回退”且作为普通的HTML特性应用在子组件的根元素上</p><ul><li>当设置inheritAttrs: true（默认）时，子组件的顶层标签元素中会渲染出父组件传递过来的属性</li><li>不管inheritAttrs为true或者false，子组件中都能通过$attrs属性获取到父组件中传递过来的属性。</li></ul><h3 id="bus中央事件总线"><a href="#bus中央事件总线" class="headerlink" title="bus中央事件总线"></a>bus中央事件总线</h3><h4 id="on和-event"><a href="#on和-event" class="headerlink" title="$on和$event"></a><code>$on</code>和<code>$event</code></h4><ul><li>$on是事件派发</li><li>$event事件监听</li><li>bus无论是嵌套还是兄弟，他们都可以互相通信<br>  A -&gt; A1<br>  B和A1通信</li></ul><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ol><li>全局定义bus:新建src&#x2F;eventBus.js文件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">EventBus</span>= <span class="keyword">new</span> <span class="title class_">Vue</span>()</span><br></pre></td></tr></table></figure></li><li>在组件中引入bus的引用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">&#x27;./bus/eventBus&#x27;</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$eventBus</span> = eventBus</span><br></pre></td></tr></table></figure></li><li>通过$emit触发事件传值，在另一个组件中的mounted中用on监听事件从而获取值<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件1</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Event</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>()<span class="comment">// 准备一个空的实例对象，相当于又new了一个vue实例，Event中含有vue的全部办法</span></span><br><span class="line"><span class="title class_">Event</span>.$emit(<span class="string">&#x27;msg&#x27;</span>,<span class="variable language_">this</span>.<span class="property">msg</span>);<span class="comment">// 发送数据，触发当前实例上的事件，要传递的数据会传递给监听器。第一个参数是发送数据名称，接收时还用这个名字接收，第二个参数是这个数据现在的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件2</span></span><br><span class="line"><span class="attr">mounted</span>:&#123;</span><br><span class="line">    <span class="title class_">Event</span>.$on(<span class="string">&#x27;msg&#x27;</span>,<span class="keyword">function</span>(<span class="params">msg</span>)&#123;<span class="comment">// 接收数据，第一个参数是数据的名字，与发送时的名字对应，第二个参数是一个方法，要对数据进行操作</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>[AIA]</p><ol><li>vue原型挂载总线<br>Vue.prototype.bus &#x3D; new Vue()</li><li>子组件发送数据<br>this.bus.$emit(“change”,data)</li><li>子组件接收数据<br>this.bus.$on(“change”,function(data){})</li></ol><h3 id="ref-x2F-refs"><a href="#ref-x2F-refs" class="headerlink" title="ref&#x2F;$refs"></a>ref&#x2F;$refs</h3><ul><li>ref:如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据，被用来给元素或子组件注册信息，引用信息将会注册在父组件的 $refs 对象上。</li><li>适用场景：当使用element-ui组件时，可用于调用组件方法，例如el-table组件的选择表格项，排序等等。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;vue.js&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="attr">sayHello</span>:() &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 app.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">ref</span>=<span class="string">&quot;comA&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> comA = <span class="variable language_">this</span>.<span class="property">$ref</span>.<span class="property">comA</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(comA.<span class="property">name</span>);<span class="comment">//vue.js</span></span></span><br><span class="line"><span class="language-javascript">            comA.<span class="title function_">sayHello</span>(); <span class="comment">//hello</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ref 这种方式，就是获取子组件的实例，然后可以直接子组件的方法和访问操作data的数据，就是父组件控制子组件的一种方式，子组件想向父组件传参或操作，只能通过其他的方式了</p><h3 id="provide-x2F-inject"><a href="#provide-x2F-inject" class="headerlink" title="provide&#x2F;inject"></a>provide&#x2F;inject</h3><ul><li>官方描述：选项需一起使用，允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在其上下游关系成立的时间里始终生效</li><li>父组件中通过provide来提供变量，然后在子组件中通过inject来注入变量</li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>provide</p><ul><li>一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。在该对象中你可以使用 Symbols 作为 key，但是只在原生支持 Symbol 和 Reflect.ownKeys 的环境下可工作。<br>inject</li><li>一个字符串数组</li><li>一个对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//祖先组件 提供foo</span></span><br><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;father&quot;</span>,</span><br><span class="line">    <span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">foo</span>:<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;father&quot;</span>,</span><br><span class="line">    <span class="attr">provide</span>:&#123;</span><br><span class="line">        <span class="attr">foo</span>:<span class="string">&#x27;hello~&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后代组件注入foo,直接当作this.foo来用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">inject</span>:[<span class="string">&#x27;foo&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    第一二种区别在哪儿？</span></span><br><span class="line"><span class="comment">        如果需要this对象属性的值，</span></span><br><span class="line"><span class="comment">        例如：</span></span><br><span class="line"><span class="comment">            provide() &#123;</span></span><br><span class="line"><span class="comment">                return &#123;</span></span><br><span class="line"><span class="comment">                    test:this.msg</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        那么第二种是传不了的，后代组件拿不到数据。所以建议只写第一种</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>[注意]一旦注入了某个数据，比如上面示例中的 foo，那这个组件中就不能再声明 foo 这个数据了，因为它已经被父级占有。</p><h3 id="provide-和-inject-绑定并不是可响应的"><a href="#provide-和-inject-绑定并不是可响应的" class="headerlink" title="provide 和 inject 绑定并不是可响应的"></a>provide 和 inject 绑定并不是可响应的</h3><p>这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。因为对象是引用类型。</p><ul><li>先来个值类型的数据（也就是字符串）例子，不会响应</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">test</span>:<span class="variable language_">this</span>.<span class="property">msg</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">msg</span>:<span class="string">&quot;Welcome to Your Vue.js App&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">msg</span> = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">_provided</span>.<span class="property">msg</span>) <span class="comment">//Welcome to Your Vue.js App</span></span><br><span class="line">        &#125;,<span class="number">3000</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样做是不行的，打印出来的 _provided 中的数据并没有改，子组件取得值也没变。若直接给 this._provided.msg 赋值，但是即使是_provided.msg 里面的值改变了，子组件的取值，依然没有变。</span></span><br></pre></td></tr></table></figure><ul><li>但参数如果是对象，就可以响应了<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">test</span>:<span class="variable language_">this</span>.<span class="property">activeData</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">activeData</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;xxxx&#x27;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">activeData</span>.<span class="property">name</span> = <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">    &#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="用project与inject实现全局变量"><a href="#用project与inject实现全局变量" class="headerlink" title="用project与inject实现全局变量"></a>用project与inject实现全局变量</h4><ul><li>将其绑定到最顶层的组件app.vue，所有后代都接收到了，就是当做全局变量来用了。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;App&#x27;</span>,</span><br><span class="line">    <span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">app</span>:<span class="variable language_">this</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">text</span>:<span class="string">&quot;weiweiwei&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="title function_">say</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;enenen&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其他所有子组件，需要全局变量的，只需按需注入app即可</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">inject</span>:[<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;app&#x27;</span>],</span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">app</span>.<span class="property">text</span>);<span class="comment">// 获取app中的变量</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">app</span>.<span class="title function_">say</span>();<span class="comment">// 可以执行app中的方法，变身为全局方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="provide-x2F-inject实现页面刷新，不闪烁"><a href="#provide-x2F-inject实现页面刷新，不闪烁" class="headerlink" title="provide&#x2F;inject实现页面刷新，不闪烁"></a>provide&#x2F;inject实现页面刷新，不闪烁</h4><ol><li>用vue-router重新路由到当前页面，页面是不进行刷新的</li><li>采用window.reload()，或者router.go(0)刷新时，整个浏览器进行了重新加载，闪烁，体验不好<br>上述办法都太行，那怎么办？</li></ol><ul><li>控制路由的组件中写一个函数（使用v-if控制router-view的显示隐藏），然后把这个函数传递给后代，然后在后代组件中调用这个方法即可刷新路由啦。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- app.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">&quot;isShowRouter&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">name</span>:<span class="string">&#x27;App&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">provide</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">reload</span>:<span class="variable language_">this</span>.<span class="property">reload</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">isShowRouter</span>:<span class="literal">false</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">reload</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">isShowRouter</span> = <span class="literal">false</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.<span class="property">isShowRouter</span> = <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 后代组件</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">inject</span>:[<span class="string">&#x27;reload&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//这里 provide 使用了函数传递给后代，然后后代调用这个函数，这种思路，也是可以做子后代向父组件传参通讯的思路了。这里的原理，和 event 事件订阅发布就很像了</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h2><ul><li>定义：除了原生标签是纯小写以外，非自定义组件纯小写标签都是内置组件</li></ul><h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><p>vue内置模板组件，它不会渲染成任何真实的dom</p><h3 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h3><p>插槽组件，它也不会渲染成任何真实的dom,只是用于接收渲染插入的内容</p><h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><p>缓存状态组件，不会渲染成真实dom，只是将被包裹的自定义组件的状态缓存到内存中</p><ul><li>多用与缓存表单填写的组件</li><li>它不能缓存v-for循环渲染出来的组件</li><li>如果它包含多个子元素的话，需要使用v-if控制显示一个子元素【props】</li><li>include 该属性控制keep-alive只缓存被指定的组件，不被指定的不缓存</li><li>exclude 该属性控制keep-alive不缓存被指定的组件，不被指定的组件缓存</li><li>max 数字，限制keep-alive缓存组件的最大个数<br>【生命周期】<br>被keep-alive包裹的组件，才拥有该生命周期</li><li>activated被keep-alive激活的生命周期</li><li>deactivated被keep-alive销毁时候的生命周期</li></ul><h4 id="keep-alive使用"><a href="#keep-alive使用" class="headerlink" title="keep-alive使用"></a>keep-alive使用</h4><ol><li><p>几种常见用法</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>:<span class="string">&#x27;test-keep-alive&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">includedComponents</span>:<span class="string">&quot;test-keep-alive&quot;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 第一种 将缓存name为test-keep-alive的组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&quot;test-keep-alive&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">component</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 第二种 将缓存name为a或b的组件，结合动态组件使用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&quot;a,b&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 第三种 使用正则表达式，需使用v-bind --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;/a|b/&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 第四种 动态判断 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;includeComponents&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 第五种 将不缓存name为test-keep-alive的组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">exclude</span>=<span class="string">&quot;test-keep-alive&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">component</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>结合router，缓存部分页面<br>[使用$route.meta的keepAlive属性]</p></li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">&quot;$route.meta.keepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">&quot;!$route.meta.keepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// router/index.js</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">routes</span>:[</span></span><br><span class="line"><span class="language-javascript">            &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">name</span>:<span class="string">&#x27;Hello&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">component</span>:<span class="title class_">Hello</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">meta</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">keepAlive</span>:<span class="literal">false</span> <span class="comment">// 不需要缓存</span></span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">path</span>:<span class="string">&#x27;/page1&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">name</span>:<span class="string">&#x27;Page1&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">component</span>:<span class="title class_">Page1</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">meta</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">keepAlive</span>:<span class="literal">true</span> <span class="comment">// 需要被缓存</span></span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        ]</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- page1页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Vue<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>两个大括号包着msg<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;输入框&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- hello页面 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>两个大括号包着msg<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    结果：在page1页面输入框输入sss,然后手动跳转到hello页面，回到page1页面之前输入的sss依然保留，说明页面信息成功保存在内存中</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br></pre></td></tr></table></figure><p>或者也可以通过动态设置route.meta的keepAlive属性来实现其他需求<br>【要求】：首页是A页面 B页面跳转到A，A页面需要缓存，C页面跳转到A，A页面不需要被缓存<br> [思路]：思路是在每个路由的beforeRouteLeave(to, from, next)钩子中设置to.meta.keepAlive：</p><ul><li>to:Route 即将要进入目标路由对象</li><li>from:Route 当前导航正要离开的路由</li><li>next：Function 一定要调用该方法来resolve这个钩子。执行效果依赖 next 方法的调用参数<ul><li>next() 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是confirmed(确认的)</li><li>next(false) 中断当前的导航。如果浏览器的URL改变了(可能是用户手动或者浏览器后退按钮)，那么URL地址会重置到from路由对应的地址</li><li>next(‘&#x2F;‘) 或者next({path:’&#x2F;‘}):跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航</li><li>next(error) 如果传入next的参数是一个error实例，则导航会被终止且该错误会被传递给router.onError()注册过的回调</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// A的路由</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:A,</span><br><span class="line">    <span class="attr">meta</span>:&#123;</span><br><span class="line">        <span class="attr">keepAlive</span>:<span class="literal">true</span> <span class="comment">// 需要缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">beforeRouteLeave</span>(<span class="params">to,<span class="keyword">from</span>,next</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置下一个路由的meta</span></span><br><span class="line">        to.<span class="property">meta</span>.<span class="property">keepAlive</span> = <span class="literal">true</span>; <span class="comment">//B跳转到A时，让A缓存，即不刷新</span></span><br><span class="line">        <span class="title function_">next</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">beforeRouteLeave</span>(<span class="params">to,<span class="keyword">from</span>,next</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置下一个路由的meta</span></span><br><span class="line">        to.<span class="property">meta</span>.<span class="property">keepAlive</span> = <span class="literal">false</span>; <span class="comment">// C 跳转到 A 时让A不缓存，即刷新</span></span><br><span class="line">        <span class="title function_">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="component动态加载组件"><a href="#component动态加载组件" class="headerlink" title="component动态加载组件"></a>component动态加载组件</h3><ul><li>特点<ol><li>必须使用动态绑定的is属性来加载组件</li><li>is属性值必须是components里注册组件的名字</li><li>让代码更简洁，更可控</li><li>它的工作形式和v-if一致，使组件加载与销毁</li></ol></li><li>实现两个子组件动态切换<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- son1 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是子组件1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span>子组件1的默认内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- son2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是子组件2<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span>子组件2的默认内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;change1&quot;</span>&gt;</span>son1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;change2&quot;</span>&gt;</span>son2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&#x27;state&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> &#123;<span class="attr">state</span>:<span class="string">&#x27;son1&#x27;</span>&#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">change1</span>(<span class="params"></span>) &#123;<span class="variable language_">this</span>.<span class="property">state</span>=<span class="string">&#x27;son1&#x27;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">change2</span>(<span class="params"></span>) &#123;<span class="variable language_">this</span>.<span class="property">state</span>=<span class="string">&#x27;son2&#x27;</span>&#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">components</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">        son1,son2</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>【Tip】</p><ol><li>son1,son2切换时，另一组件被销毁，所以，当两个组件进行动态切换时，组件的状态是：不断创建与销毁的过程</li><li>如果想把组件缓存下来，可以在动态组件上使用vue另一个内置组件keep-alive <keep-alive>     <component :is="state"></component> </keep-alive></li></ol><h4 id="父子组件执行顺序的问题："><a href="#父子组件执行顺序的问题：" class="headerlink" title="父子组件执行顺序的问题："></a>父子组件执行顺序的问题：</h4><ul><li>问：我们在父组件和子组件son中分别定义个生命周期钩子mounted，页面加载到完成，父组件先渲染完成还是子组件先渲染完成呢？</li><li>答：结果是父组件挂载完成前提：需等到子组件挂载完成后</li><li>问：子组件先挂载完成，父组件才能挂载完成，下边代码我们在父组件中获取子组件的dom元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">son</span> <span class="attr">ref</span>=<span class="string">&#x27;son&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 子组件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> son = &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">template</span>:</span></span><br><span class="line"><span class="language-javascript">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>双括号里包着name<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="language-javascript">        ,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> &#123;<span class="attr">name</span>:<span class="string">&#x27;hhh&#x27;</span>&#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;lll&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 父组件(根实例)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">son</span>.<span class="property">$el</span>.<span class="property">innerText</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">components</span>:&#123;son&#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 上边代码，在子组件的mounted中我们修改了原来data对象中的数据，页面渲染完全没问题，但是在父组件mouted中输出子组件dom元素的内容时，不是新数据 &quot;lll&quot;，而是原来的数据 &quot;hhh&quot;  --&gt;</span></span><br></pre></td></tr></table></figure><p>【结论】子组件生命周期钩子mounted和父组件的mounted都是同步执行的，但是子组件渲染却是异步渲染的，所以在父组件的mounted中获取dom元素是原来的子组件数据！！<br>[解决上述bug] 用vm.$nextTick中去获取dom元素</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">    .......</span><br><span class="line"><span class="comment">// 父组件(根实例)</span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.$nextTick(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">son</span>.<span class="property">$el</span>.<span class="property">innerText</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">components</span>:&#123;son&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="BTW——el和-el"><a href="#BTW——el和-el" class="headerlink" title="BTW——el和$el"></a>BTW——el和$el</h3><ul><li>el是Vue实例的挂载目标，实例挂载后，元素可以用xx.$el访问。挂载阶段还没开始的时候,$el属性是不可见的。vue生命周期mounted阶段，el被新创建的xx.$el替换，这个时候Vue实例的挂载目标确定，DOM渲染完毕</li></ul><h3 id="transition动画组件"><a href="#transition动画组件" class="headerlink" title="transition动画组件"></a>transition动画组件</h3><h4 id="组件出现过度-x2F-动画效果的原因"><a href="#组件出现过度-x2F-动画效果的原因" class="headerlink" title="组件出现过度&#x2F;动画效果的原因"></a>组件出现过度&#x2F;动画效果的原因</h4><p>【当插入或删除包含在transition组件中的元素时，Vue将会做以下处理】：</p><ol><li>自动嗅探目标元素是否应用里css过度或动画，如果是，在恰当的时机添加&#x2F;删除css类名</li><li>如果过度组件提供了JS钩子函数，这些钩子函数将在恰当时机被调用</li><li>如果没有找到JS钩子函数也没有检测到css过渡&#x2F;动画，DOM操作(插入&#x2F;删除)在下一帧中立即执行。(注意：此浏览器逐帧动画机制，和Vue的nextTick概念不同)</li></ol><h4 id="transition组件在什么情况下可以生成动画效果？"><a href="#transition组件在什么情况下可以生成动画效果？" class="headerlink" title="transition组件在什么情况下可以生成动画效果？"></a>transition组件在什么情况下可以生成动画效果？</h4><p>【Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入&#x2F;离开过渡动画效果】</p><ol><li>条件渲染(使用v-if)，可以使用key代替v-if</li><li>条件展示(使用v-show)</li><li>动态组件<br> <component :is='currentTabComponent'></component></li><li>组件根节点<br> transition&#x2F;transition-group作为跟组件，形成可服用动态组件</li></ol><h4 id="transition组件生成动画效果的方式"><a href="#transition组件生成动画效果的方式" class="headerlink" title="transition组件生成动画效果的方式"></a>transition组件生成动画效果的方式</h4><p>【Vue在插入、更新或者移除DOM 时，提供了以下不同方式的应用过渡效果】：</p><ol><li>在css过渡和动画中自动应用class</li><li>可以配合使用第三方css动画库，如animate.css</li><li>在过渡钩子函数中使用javascript 直接操作 dom</li><li>可以配合使用第三方 JavaScript 动画库，如 Velocity.js</li></ol><h4 id="分别详细介绍"><a href="#分别详细介绍" class="headerlink" title="分别详细介绍"></a>分别详细介绍</h4><ol><li>【css过渡】：常用的过渡都是使用 CSS 过渡，也就是 组件和css3属性transition连用</li></ol><h5 id="api"><a href="#api" class="headerlink" title="api"></a>api</h5><ul><li>name 指定自己写的动画类名前缀</li><li>v-enter: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。</li><li>enter-class-active 进入动画的类名</li><li>leave-class-active 离开动画的类名</li><li>duration 设置动画执行的间隔时间</li><li>v-enter-active: 定义过渡的状态。在元素整个过渡过程中作用，在元素被插入时生效，在 transition&#x2F;animation 完成之后移除。 这个类可以被用来定义过渡的过程时间，延迟和曲线函数。</li><li>v-enter-to: 定义进入过渡的结束状态。在元素被插入一帧后生效（于此同时 v-enter 被删除），在 transition&#x2F;animation 完成之后移除。</li><li>v-leave: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。</li><li>v-leave-active: 定义过渡的状态。在元素整个过渡过程中作用，在离开过渡被触发后立即生效，在 transition&#x2F;animation 完成之后移除。 这个类可以被用来定义过渡的过程时间，延迟和曲线函数。</li><li>v-leave-to: 定义离开过渡的结束状态。在离开过渡被触发一帧后生效（于此同时 v-leave 被删除），在transition&#x2F;animation 完成之后移除。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;show = !show&quot;</span>&gt;</span></span><br><span class="line">        toggle coustom class</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">&quot;bounce&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">enter-active-class</span>=<span class="string">&quot;animated tada&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">leave-active-class</span>=<span class="string">&quot;animated bounceOutRight&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;show&quot;</span>&gt;</span>自定义过渡类名<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 样式如此设置，只需要控制show是false还是true，即可有淡入淡出效果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.fade-enter-active</span>,<span class="selector-class">.fade-leave-active</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">transition</span>: opacity <span class="number">0.5s</span>;       </span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.fade-enter</span>,<span class="selector-class">.fade-leave-to</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">opacity</span>:<span class="number">0</span></span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">show</span>:<span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对于这些enter/leave过渡中切换的类名，v-是这些类名的前缀。使用使用&lt;transition name=&quot;my-transition&quot; 可以重置前缀，比如 v-enter 替换为 my-transition-enter。 --&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>【过渡可以和其他第三方 CSS 动画库连用】</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;transition </span><br><span class="line">    name=<span class="string">&quot;bounce&quot;</span></span><br><span class="line">    enter-active-<span class="keyword">class</span>=<span class="string">&quot;animated tada&quot;</span></span><br><span class="line">    leave-active-<span class="keyword">class</span>=<span class="string">&quot;animated bounceOutRight&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;show&quot;</span>&gt;</span>自定义过渡类名<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/transition&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">show</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 不需要设置样式，只需要控制show是false还是true，即可有动画效果</span></span><br></pre></td></tr></table></figure><ol start="3"><li>【CSS 动画】</li></ol><ul><li>CSS 动画是transition组件和css3属性animation连用，用法和 CSS 过渡相同</li><li>区别是：在动画中 v-enter 类名在节点插入DOM后不会立即删除，而是在 animationend 事件触发时删除。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;bounce&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;show&quot;</span>&gt;</span>使用animation做动画效果<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">     <span class="selector-class">.bounce-enter-active</span>&#123;<span class="attribute">animation</span>:bounce-in <span class="number">0.5s</span>&#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.bounce-leave-active</span>&#123;<span class="attribute">animation</span>:bounce-in <span class="number">0.5s</span> reverse&#125;</span></span><br><span class="line"><span class="language-css">    <span class="keyword">@keyframes</span> bounce-in&#123;</span></span><br><span class="line"><span class="language-css">        <span class="number">0%</span>&#123;<span class="attribute">transform</span>:<span class="built_in">scale</span>(<span class="number">0</span>)&#125;</span></span><br><span class="line"><span class="language-css">        <span class="number">50%</span>&#123;<span class="attribute">transform</span>:<span class="built_in">scale</span>(<span class="number">1.5</span>)&#125;</span></span><br><span class="line"><span class="language-css">        <span class="number">100%</span>&#123;<span class="attribute">transform</span>:<span class="built_in">scale</span>(<span class="number">1</span>)&#125;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>【transition组件和JavaScript 钩子连用】</li></ol><ul><li>当只用js过渡的时候，在enter和leave中必须使用done进行回调。否则，它们将被同步调用，过渡会立即完成</li><li>推荐对于仅使用JS过渡的元素v-bind:css&#x3D;”false”,Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">before-enter</span>=<span class="string">&quot;beforeEnter&quot;</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">enter</span>=<span class="string">&quot;enter&quot;</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">after-enter</span>=<span class="string">&quot;afterEnter&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:before-leave</span>=<span class="string">&quot;beforeLeave&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:leave</span>=<span class="string">&quot;leave&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:after-leave</span>=<span class="string">&quot;afterLeave&quot;</span></span></span><br><span class="line"><span class="tag"> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;ball&quot;</span> <span class="attr">v-show</span>=<span class="string">&quot;show&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>:&#123;<span class="attr">show</span>:<span class="literal">true</span>&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//el 即操作的元素对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">beforeEnter</span>(<span class="params">el</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        el.<span class="property">style</span>.<span class="property">transform</span>=<span class="string">&#x27;translate(80px,80px)&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">enter</span>(<span class="params">el,done</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 必须下面加下面一行，否则不会出现应有的效果</span></span></span><br><span class="line"><span class="language-javascript">        el.<span class="property">offsetWidth</span>;<span class="comment">//这里可以理解成强制浏览器刷新，也可以写成el.offsetHeight</span></span></span><br><span class="line"><span class="language-javascript">        el.<span class="property">style</span>.<span class="property">transition</span>=<span class="string">&#x27;all 1.5s ease&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        el.<span class="property">style</span>.<span class="property">transform</span>=<span class="string">&#x27;translate(0,0)&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">done</span>()</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">afterEnter</span>(<span class="params">el</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        cnosole.<span class="title function_">log</span>(<span class="string">&#x27;afterEnter&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// this.flag=false;//隐藏小球</span></span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">beforeLeave</span>:<span class="keyword">function</span>(<span class="params">el</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        el.<span class="property">style</span>.<span class="property">transform</span>=<span class="string">&#x27;translate(0,0)&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 当与CSS结合时</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 回调函数done是可选的</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">leave</span>:<span class="keyword">function</span>(<span class="params">el,done</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        el.<span class="property">offsetWidth</span>;<span class="comment">//这里可以理解成强制浏览器刷新，也可以写el.offsetHeight</span></span></span><br><span class="line"><span class="language-javascript">        el.<span class="property">style</span>.<span class="property">transition</span>=<span class="string">&#x27;all 3s ease&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        el.<span class="property">style</span>.<span class="property">transform</span>=<span class="string">&#x27;translate(80px 80px)&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 这是直接调用done的话由于会立即删除元素导致动画不执行</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">done</span>()</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 解决办法</span></span></span><br><span class="line"><span class="language-javascript">        方法<span class="number">1</span>：不调用done可以进行动画，但是元素依旧存在，并且afterLeave函数钩子不执行</span></span><br><span class="line"><span class="language-javascript">        方法<span class="number">2</span>：</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//setTimeout可以解决这个问题，让done不立即执行，过几秒后再执行setTimeout(done,3000);//时间根据自己设定的动画时间确定</span></span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">afterLeave</span>:<span class="keyword">function</span>(<span class="params">el</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;afterLeave&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>[注意]：在leave函数钩子中，直接调用done函数，会立即删除元素导致动画不执行</p><ul><li>和JS动画库Velocity一起使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;div id=&quot;app5&quot;&gt;</span></span><br><span class="line"><span class="comment">//     &lt;button @click=&quot;show = !show&quot;&gt;toggle hook&lt;/button&gt;</span></span><br><span class="line"><span class="comment">//     &lt;transition @before-enter=&quot;beforeEnter&quot;</span></span><br><span class="line"><span class="comment">//                 @enter=&quot;enter&quot;</span></span><br><span class="line"><span class="comment">//                 @leave=&quot;leave&quot;</span></span><br><span class="line"><span class="comment">//                 :css=&quot;false&quot;&gt;</span></span><br><span class="line"><span class="comment">//             &lt;p v-if=&quot;show&quot;&gt;javascript 钩子使用&lt;/p&gt;</span></span><br><span class="line"><span class="comment">//     &lt;/transition&gt;</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="attr">beforeEnter</span>:<span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(el);</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&quot;beforeEnter&quot;</span>);</span><br><span class="line">            el.<span class="property">style</span>.<span class="property">opacity</span> = <span class="number">0</span></span><br><span class="line">            el.<span class="property">style</span>.<span class="property">transformOrigin</span> = <span class="string">&#x27;left&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">enter</span>:<span class="keyword">function</span> (<span class="params">el, done</span>) &#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&quot;enter&quot;</span>);</span><br><span class="line">        <span class="comment">//    console.log(done);</span></span><br><span class="line">            <span class="title class_">Velocity</span>(el, &#123;<span class="attr">opacity</span>:<span class="number">1</span>, <span class="attr">fontSize</span>:<span class="string">&#x27;1.4em&#x27;</span>&#125;, &#123;<span class="attr">duration</span>:<span class="number">300</span>&#125;);</span><br><span class="line">            <span class="title class_">Velocity</span>(el, &#123;<span class="attr">fontSize</span>:<span class="string">&#x27;1em&#x27;</span>&#125;, &#123;<span class="attr">complete</span>:done&#125;);</span><br><span class="line">            <span class="title class_">Velocity</span>(el,<span class="string">&quot;reverse&quot;</span>, &#123; <span class="attr">duration</span>: <span class="number">6000</span> &#125;);</span><br><span class="line">            <span class="title class_">Velocity</span>(el,&#123;</span><br><span class="line">                        <span class="attr">borderBottomWidth</span>: [ <span class="string">&quot;2px&quot;</span>, <span class="string">&quot;spring&quot;</span> ], <span class="comment">// Uses &quot;spring&quot;</span></span><br><span class="line">                    <span class="attr">width</span>: [ <span class="string">&quot;100px&quot;</span>, [ <span class="number">250</span>, <span class="number">15</span> ] ], <span class="comment">// Uses custom spring physics</span></span><br><span class="line">                        <span class="attr">height</span>: <span class="string">&quot;100px&quot;</span> <span class="comment">// Defaults to easeInSine, the call&#x27;s default easing</span></span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                            <span class="attr">easing</span>: <span class="string">&quot;easeInSine&quot;</span> <span class="comment">// Default easing</span></span><br><span class="line">                    &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">leave</span>:<span class="keyword">function</span> (<span class="params">el, done</span>) &#123;</span><br><span class="line">            <span class="title class_">Velocity</span>(el, &#123;<span class="attr">translateX</span>:<span class="string">&#x27;15px&#x27;</span>, <span class="attr">rotateZ</span>:<span class="string">&#x27;50deg&#x27;</span>&#125;, &#123;<span class="attr">duration</span>:<span class="number">600</span>&#125;)</span><br><span class="line">            <span class="title class_">Velocity</span>(el, &#123;<span class="attr">rotateZ</span>:<span class="string">&#x27;100deg&#x27;</span>&#125;, &#123;<span class="attr">loop</span>:<span class="number">2</span>&#125;)</span><br><span class="line">            <span class="title class_">Velocity</span>(el,&#123;</span><br><span class="line">                <span class="attr">rotateZ</span>:<span class="string">&#x27;45deg&#x27;</span>,</span><br><span class="line">                <span class="attr">translateY</span>:<span class="string">&#x27;30px&#x27;</span>,</span><br><span class="line">                <span class="attr">translateX</span>:<span class="string">&#x27;30px&#x27;</span>,</span><br><span class="line">                <span class="attr">opacity</span>:<span class="number">0</span></span><br><span class="line">            &#125;, &#123;<span class="attr">complete</span>:done&#125;)</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li>【组件间切换的动态效果实现】<br>组件的过渡-不需要使用key attribute。使用动态组件component，进行切换</li><li>【元素间切换的动态效果实现】</li></ol><ul><li>6.1原生标签可以使用 v-if&#x2F;v-else <transition>    <button v-if="isEdting" key="save">      Save    </button>    <button v-else key="edit">      Edit    </button>  </transition></li></ul><p>[注意]：当有相同标签名的元素切换时(比如两个div元素)，必须通过 key attribute 设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容（也就是不会有动画效果）。</p><ul><li><p>6.2设置key代替v-if&#x2F;v-else</p>  <transition>    <button v-bind:key="isEdting">    双括号中间包着isEdting ? 'Save':'Edit'    </button>  </transition></li><li><p>6.3两种过渡模式<br>多个元素间的过度动画（一个元素离开，一个元素进入），是同时生效的。这种情形不能满足所有要求，所以 Vue 提供了过渡模式。</p><ol><li>in-out：新元素先进行过渡，完成之后当前元素过渡离开。</li><li>out-in：当前元素先进行过渡，完成之后新元素过渡进入  <transition name="fade" mode="out-in">  <!-- ... the buttons ...-->  </transition></li></ol></li></ul><ol start="7"><li>【可复用过渡组件】<br>过渡可以通过 Vue 的组件系统实现复用。要创建一个可复用过渡组件，你需要做的就是将  或者  作为根组件，然后将任何子组件放置在其中就可以了。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-special-transition&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">template</span>: <span class="string">&#x27;\ name=&quot;very-special-transition&quot;\</span></span><br><span class="line"><span class="string">        mode=&quot;out-in&quot;\</span></span><br><span class="line"><span class="string">        v-on:before-enter=&quot;beforeEnter&quot;\</span></span><br><span class="line"><span class="string">        v-on:after-enter=&quot;afterEnter&quot;\</span></span><br><span class="line"><span class="string">    &gt;\\</span></span><br><span class="line"><span class="string">\</span></span><br><span class="line"><span class="string">&#x27;</span>,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line"><span class="attr">beforeEnter</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;<span class="comment">// ...</span></span><br><span class="line">                        &#125;,</span><br><span class="line"><span class="attr">afterEnter</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;<span class="comment">// ...</span></span><br><span class="line">                        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">函数组件更适合完成这个任务：</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-special-transition&#x27;</span>, &#123;</span><br><span class="line"><span class="attr">functional</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">render</span>: <span class="keyword">function</span> (<span class="params">createElement, context</span>) &#123;<span class="keyword">var</span> data = &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;very-special-transition&#x27;</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;out-in&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">on</span>: &#123;</span><br><span class="line"><span class="attr">beforeEnter</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;<span class="comment">// ...</span></span><br><span class="line">                            &#125;,</span><br><span class="line"><span class="attr">afterEnter</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;<span class="comment">// ...</span></span><br><span class="line">                            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createElement</span>(<span class="string">&#x27;transition&#x27;</span>, data, context.<span class="property">children</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="BTW——当内置组件混合使用时的嵌套顺序"><a href="#BTW——当内置组件混合使用时的嵌套顺序" class="headerlink" title="BTW——当内置组件混合使用时的嵌套顺序"></a>BTW——当内置组件混合使用时的嵌套顺序</h3><p>transition&gt;keep-alive&gt;component</p><h3 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h3><p>用不同的输入参数一次又一次地执行相同的代码块，直到达到结束点<br>[注意点]</p><ol><li>数据源必须来自上游</li><li>递归组件必须要有”name”属性，且值与组件文件名一致</li><li>必须要有v-if的终止渲染条件<br>v-if &#x3D;”activeld” &amp;&amp; datalist[activeld].children<br>即需要 datalist[activeId] 存在 &amp;&amp; datalist[activeId] <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 假设我们在windows中绑定了一个arr --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;arr.length&gt;0||arr!=null&quot;</span>&gt;</span>hhh<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 报错出现在我们的前半条判断中，在我们判断数组的长度是否大于零的时候，需要先判断我们是否有数组，如果没有数组的话，那么这条数据就会发生报错 --&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="BTW——自定义组件"><a href="#BTW——自定义组件" class="headerlink" title="BTW——自定义组件"></a>BTW——自定义组件</h3><p>要么首字母大写，要么用中划线的方式</p><h1 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h1><ul><li>等所有dom更新完毕后触发(执行其指定的回调)，因为vue中dom更新是异步的才有这个东西</li><li>语法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="variable language_">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 获取更新后的dom内容</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">this</span>.$nextTick().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 获取更新后的dom内容</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>应用场景</li></ul><ol><li>created()进行DOM操作一定要放在Vue.nextTick()的回调函数</li><li>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中</li></ol><h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><p>在不修改原始数据的情况下，对数据进行计算并返回新数据，该方法只能用在插值语法中</p><ul><li>双大括号插值和v-bind 表达式（后者从2.1.0+开始支持）</li></ul><h2 id="过滤器函数总接收表达式的值作为第一个参数"><a href="#过滤器函数总接收表达式的值作为第一个参数" class="headerlink" title="过滤器函数总接收表达式的值作为第一个参数"></a>过滤器函数总接收表达式的值作为第一个参数</h2><!-- 在双大括号中 -->   <p>两个大括号中间写着 message |</p><!-- 在v-bind 中 --><div v-bind:msg="message | filter"></div>在上述例子汇总，filter过滤器函数将会收到message的值作为第一个参数<h2 id="过滤器可以串联"><a href="#过滤器可以串联" class="headerlink" title="过滤器可以串联"></a>过滤器可以串联</h2><ul><li>两个大括号中间写着 message | filterA | filterB<br>在这个例子中，filterA被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将filterA的结果传递到filterB中</li></ul><h2 id="过滤器是javascript-函数可以接收参数"><a href="#过滤器是javascript-函数可以接收参数" class="headerlink" title="过滤器是javascript 函数可以接收参数"></a>过滤器是javascript 函数可以接收参数</h2><ul><li>两个大括号中间写着 message | filterA(‘arg1’,arg2<br>filterA被定义为接收三个参数的过滤器函数。其中message的值作为第一个参数，普通字符串’arg1’作为第二个参数，表达式arg2作为第三个参数</li></ul><h2 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h2><p>filter 每次只能写一个</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&quot;prefix&quot;</span>,<span class="function">(<span class="params">n</span>) =&gt;</span> <span class="string">&quot;¥&quot;</span>+n)</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><code>|</code> 叫管道符号</p><ul><li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(filterName,<span class="function">() =&gt;</span> &#123;<span class="keyword">return</span> <span class="comment">//数据处理结果&#125;)</span></span><br></pre></td></tr></table></figure></li><li>实际开发使用</li><li>step1 用在数据修饰上，通常我们把函数抽离出去，统一放在个.js文件中</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// filter.js</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">filterPrice</span>=(<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;已收款&#x27;</span> + value.<span class="string">&#x27;元&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">filterDate</span>=(<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="string">&#x27;天&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;filterPrice,filterDate&#125;</span><br></pre></td></tr></table></figure><ul><li>step2 在main.js中导入上边filter.js文件，也可以在任何组件中导入filter.js这个文件，但对于全局过滤器来说，最好是在main.js中定义，导入的是一个对象，所以使用Object.keys()方法，得到一个由key组成的数组，遍历数组，让key作为全局过滤器的名字，后面的是key对应的处理函数，这样在任何一个组件中都可以使用全局过滤器了</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">    <span class="comment">// 两种导入方式 推荐第一种</span></span><br><span class="line">    <span class="keyword">import</span> * <span class="keyword">as</span> filters <span class="keyword">from</span> <span class="string">&#x27;./filter&#x27;</span></span><br><span class="line">    <span class="keyword">import</span> &#123;filterPrice,filterDate&#125; <span class="keyword">from</span> <span class="string">&#x27;./filter&#x27;</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(filters.<span class="property">default</span>).<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title class_">Vue</span>.<span class="title function_">filter</span>(item,filters.<span class="property">default</span>[item])</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">        router,</span><br><span class="line">        store,</span><br><span class="line">        <span class="attr">render</span>:<span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">    &#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>step3<br>在组件中使用 全局过滤器</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;filterCount&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>两个大括号中间写 filterCount | filterPrice<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>两个大括号中间写 filterCount | filterDate<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">filterCount</span>:<span class="number">1500</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="组件过滤器"><a href="#组件过滤器" class="headerlink" title="组件过滤器"></a>组件过滤器</h2><p>filters可以写很多个</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">filters</span>:&#123;<span class="title function_">n1</span>(<span class="params">n</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> n+<span class="number">2</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;filterCount&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;filter&quot;</span>&gt;</span>两个大括号中间写 filterCount | changeCapitalLetter<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">filterCount</span>:<span class="string">&#x27;hello&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">filters</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">changeCapitalLetter</span>(<span class="params">value</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// value是输入框的内容也是要显示的</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(value) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">let</span> str = value.<span class="title function_">toString</span>();</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 获取英文，以空格分组把字符串转为数组，遍历每一项第一项转为大写字母</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">let</span> newArr = str.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">map</span>(<span class="function"><span class="params">ele</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">return</span> ele.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUppeCase</span>()+ele.<span class="title function_">slice</span>(<span class="number">1</span>)</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span> newArr.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>) <span class="comment">// 数组转字符串以空格输出</span></span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>常见使用场景：格式日期(时间)，金钱单位，保留小数位</li></ul><h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><ul><li>定义:[简单来说]就是模块化就是将变量和函数,放入不同的文件中</li></ul><h2 id="模块的优点"><a href="#模块的优点" class="headerlink" title="模块的优点?"></a>模块的优点?</h2><ol><li>可维护性强:因为模块独立，代码依赖小，自己可以独立更新和改进</li><li>命名空间:一般一个变量在最顶级的函数外声明，可以全局使用，易出现命名冲突的情况。使用模块化开发来封装变量，可以避免全局污染</li><li>重用代码：通过模块引用的方式，来复用代码</li></ol><h2 id="CommonJS-AMD-x2F-CMD"><a href="#CommonJS-AMD-x2F-CMD" class="headerlink" title="CommonJS AMD&#x2F;CMD"></a>CommonJS AMD&#x2F;CMD</h2><ul><li>定义：CommonJS是一种规范语法，内容有很多种，nodejs是这种规范的实现<br>【扩展】：1.SeaJS是模块加载器，是用CMD规范<br>    2.AMD&#x2F;CMD是从 CommonJS 讨论中诞生的<br>    3.RequireJS 遵循 AMD（异步模块定义）规范<br>    4.Sea.js 遵循 CMD （通用模块定义）规范<br>  规范的不同，导致了两者 API 不同。<br>  [AMD] 提前执行：提前异步并行加载<br>      优点：尽早执行依赖可以尽早发现错误<br>      缺点：易产生浪费<br>  [CMD] 延迟执行：延迟按需加载<br>      优点：减少资源浪费<br>      缺点：等待时间长、出错时间延后<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CMD 依赖就近 </span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>,<span class="built_in">exports</span>,<span class="variable language_">module</span></span>)&#123;<span class="comment">// 定义模块</span></span><br><span class="line">    <span class="keyword">var</span> demo=<span class="built_in">require</span>(<span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line">    <span class="keyword">var</span> x=demo.<span class="title function_">demo</span>()</span><br><span class="line">    <span class="keyword">var</span> web=&#123;</span><br><span class="line">        <span class="attr">add</span>:<span class="keyword">function</span>(<span class="params">x</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> x+y</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">web</span>:web</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>  [RequireJS] 前端模块化管理工库<br>      详解：通过一个函数来将所有所需要的或者说所依赖的模块实现装载进来，然后返回一个新函数(模块)，我们所有关于新模块的业务代码都在这个函数内部操作，其内部也可以无限制的使用已经加载进来的模块<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">require</span>.<span class="title function_">config</span>(&#123;</span><br><span class="line">    <span class="attr">abc</span>:&#123;</span><br><span class="line">        <span class="string">&#x27;boostrap&#x27;</span>:&#123;</span><br><span class="line">            <span class="attr">deps</span>:[<span class="string">&#x27;jquery&#x27;</span>],</span><br><span class="line">            <span class="attr">exports</span>:<span class="string">&#x27;boostrap&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">paths</span>:&#123;</span><br><span class="line">        <span class="string">&quot;jquery&quot;</span>:<span class="string">&quot;路径&quot;</span>,</span><br><span class="line">        <span class="string">&quot;boostrap&quot;</span>:<span class="string">&quot;路径&quot;</span>,</span><br><span class="line">        <span class="string">&quot;index&quot;</span>:<span class="string">&quot;index&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;jquery&#x27;</span>,<span class="string">&#x27;boostrap&#x27;</span>,<span class="string">&#x27;index&#x27;</span>],<span class="keyword">function</span>(<span class="params">$,bootstrap,index</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(index.<span class="property">web</span>.<span class="title function_">add</span>(<span class="number">11</span>));</span><br><span class="line">    $(<span class="string">&quot;.p1&quot;</span>).<span class="title function_">text</span>(index.<span class="property">web</span>.<span class="title function_">add</span>(<span class="number">11</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="ES6模块"><a href="#ES6模块" class="headerlink" title="ES6模块"></a>ES6模块</h2><ul><li>导入导出<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;AI&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> phone = <span class="string">&#x27;3571678&#x27;</span></span><br><span class="line"><span class="keyword">var</span> hobby = <span class="string">&#x27;购物&#x27;</span>;</span><br><span class="line"><span class="comment">// 普通导出导入</span></span><br><span class="line">    <span class="keyword">export</span> &#123;name, phone, hobby&#125;;</span><br><span class="line">    <span class="comment">// 导入</span></span><br><span class="line">    <span class="keyword">import</span> &#123;name, phone, hobby&#125; <span class="keyword">from</span> <span class="string">&#x27;./views/moduleA&#x27;</span> </span><br><span class="line"><span class="comment">// 导出export别名</span></span><br><span class="line">    <span class="keyword">export</span> &#123; name <span class="keyword">as</span> v1, age <span class="keyword">as</span> v2, hobby <span class="keyword">as</span> v3&#125;;</span><br><span class="line">    <span class="comment">// 导入</span></span><br><span class="line">    <span class="keyword">import</span> &#123;v1, v2, v3&#125; <span class="keyword">from</span> <span class="string">&#x27;./views/moduleA&#x27;</span>;</span><br><span class="line"><span class="comment">//导出export default仅有一个</span></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;<span class="attr">name</span>:<span class="string">&#x27;lll&#x27;</span>,<span class="attr">hobby</span>:<span class="string">&#x27;games&#x27;</span>&#125;</span><br><span class="line">    <span class="comment">// 导入</span></span><br><span class="line">    <span class="keyword">import</span> obj <span class="keyword">from</span> <span class="string">&#x27;./views/moduleD&#x27;</span></span><br><span class="line"><span class="comment">// 定义公共数据</span></span><br><span class="line">    <span class="comment">// 性别</span></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">const</span> sexData=[</span><br><span class="line">        &#123;<span class="attr">key</span>:<span class="string">&#x27;man&#x27;</span>,<span class="attr">value</span>:<span class="string">&#x27;男&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">key</span>:<span class="string">&#x27;woman&#x27;</span>,<span class="attr">value</span>:<span class="string">&#x27;女&#x27;</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">//用户</span></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">const</span> userData = [</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;1&#x27;</span>,<span class="attr">value</span>:<span class="string">&#x27;name1&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;2&#x27;</span>,<span class="attr">value</span>:<span class="string">&#x27;name2&#x27;</span>&#125; </span><br><span class="line">    ];</span><br><span class="line">    <span class="comment">// 导入</span></span><br><span class="line">    <span class="keyword">import</span> &#123;sexData,userData&#125; <span class="keyword">from</span> <span class="string">&#x27;./views/moduleB&#x27;</span> </span><br></pre></td></tr></table></figure></li><li>图片的导入<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.直接导入 &lt;img src=&#x27;&#x27;&gt;</span></span><br><span class="line"><span class="comment">// 2.通过import</span></span><br><span class="line">    <span class="keyword">import</span> img1 <span class="keyword">from</span> <span class="string">&#x27;./assets/img/1.jpg&#x27;</span> <span class="comment">//导入图片</span></span><br><span class="line">    &lt;img :src=<span class="string">&quot;img1&quot;</span> /&gt;&lt;/div&gt; </span><br><span class="line"><span class="comment">// 3.通过require的方式</span></span><br><span class="line">   <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">return</span>&#123;</span><br><span class="line">           <span class="attr">img</span>:[</span><br><span class="line">               <span class="built_in">require</span>(<span class="string">&quot;@/assets/img/1.jpg&quot;</span>),</span><br><span class="line">               <span class="built_in">require</span>(<span class="string">&quot;@/assets/img/2.jpg&quot;</span>)</span><br><span class="line">           ]</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="common-js和es6模块的区别？"><a href="#common-js和es6模块的区别？" class="headerlink" title="common.js和es6模块的区别？"></a>common.js和es6模块的区别？</h2><p>node使用的是commonjs 在使用模块的时候是运行时同步加载的，拷贝模块中的对象，模块可以多次加载，但只会在第一次加载，之后会被缓存，引入的是缓存中的值</p><ul><li>commonjs输出的是一个值的拷贝，而es6输出的是值的引用</li><li>commonjs是运行时加载，es6是编译时输出接口</li></ul><h1 id="混入mixins"><a href="#混入mixins" class="headerlink" title="混入mixins"></a>混入mixins</h1><ul><li>定义：将多个组件内重复使用的js部分抽离出来，作为混入文件，哪里复用插哪里</li></ul><h2 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mixins.js</span></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">      <span class="comment">// ...组件内所有的配置，这里都有</span></span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>)&#123;&#125;,</span><br><span class="line">        <span class="attr">props</span>:[],</span><br><span class="line">        <span class="attr">methods</span>:&#123;&#125;,</span><br><span class="line">        <span class="comment">// 生命周期</span></span><br><span class="line">        <span class="attr">mixins</span>:[],</span><br><span class="line">        <span class="attr">components</span>:&#123;&#125;,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line">    <span class="keyword">import</span> mixins <span class="keyword">from</span> <span class="string">&quot;./mixins&quot;</span>;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">        <span class="attr">mixins</span>:[mixins,p,p]<span class="comment">//为什么要写成数组形式？因为这里面有顺序,若函数有重复会依次合并，</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>为了复用代码，复用js，三个组件，每个组件内都有同一个业务，同一个事件，并且事件的处理内容都一样</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>只能复用js，且组成部分与vue组件中的script完全一致</p><h2 id="混入的优缺点"><a href="#混入的优缺点" class="headerlink" title="混入的优缺点"></a>混入的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>节省代码量，让代码高复用，降低了代码的重复率。让vue组件’瘦身’</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>容易冲突，不好控制，后期维护成本高</p><h2 id="执行顺序及特性"><a href="#执行顺序及特性" class="headerlink" title="执行顺序及特性"></a>执行顺序及特性</h2><p>执行顺序是先执行混入文件后执行组件。如果mixins里有多个混入的话，会按照顺序依次执行</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li>数据、函数，如果组件内和混入里的命名重复了则使用组件内的覆盖混入里的</li><li>如果混入里和组件内有相同的生命周期，则两个生命周期都会执行，先执行混入后执行组件</li></ol><h2 id="extends扩展"><a href="#extends扩展" class="headerlink" title="extends扩展"></a>extends扩展</h2><p>扩展执行表现形式和混入完全一样</p><h2 id="extends和mixins区别"><a href="#extends和mixins区别" class="headerlink" title="extends和mixins区别"></a>extends和mixins区别</h2><ul><li>扩展只能挂载一个</li><li>而混入可以使用数组的方式挂载很多个混入</li></ul><h1 id="数据监听"><a href="#数据监听" class="headerlink" title="数据监听"></a>数据监听</h1><h2 id="方法一：利用keyup事件来实现"><a href="#方法一：利用keyup事件来实现" class="headerlink" title="方法一：利用keyup事件来实现"></a>方法一：利用keyup事件来实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 定义一个getFullName函数</span></span><br><span class="line">        <span class="comment">// &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot; @keyup =&quot;getFullName&quot;&gt; +</span></span><br><span class="line">        <span class="comment">// &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot; @keyup=&quot;getFullName&quot;&gt; =</span></span><br><span class="line">        <span class="comment">// &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot; @keyup=&quot;getFullName&quot;&gt; </span></span><br><span class="line"><span class="comment">// 在vm中定义方法</span></span><br><span class="line">    <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="attr">lastname</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="attr">firstname</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="attr">fullname</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="title function_">getFullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">fullname</span> = <span class="variable language_">this</span>.<span class="property">lastname</span>+<span class="string">&#x27;-&#x27;</span>+<span class="variable language_">this</span>.<span class="property">firstname</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="watch侦听器"><a href="#watch侦听器" class="headerlink" title="watch侦听器"></a>watch侦听器</h2><ul><li>专门用于监听数据变化的<br>  使用这个属性，可以监视data中指定数据的变化，然后触发这个watch中对应的function可以不用绑定事件</li></ul><h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><ul><li>在watch中可以对另外一个数据修改</li><li>可以对监听的数据进行固定值赋值，因为watch会新旧值对比，发现一致则不会再触发监听了</li><li>监听数据，赋值如果是递增或递减则会报错</li><li>默认只能是监听基本数据类型和数组的值</li><li>如果监听的是对象，则需要对象写法</li><li>不需要返回值</li><li>它可以执行异步操作：定时器、ajax</li></ul><h3 id="watch–监听数据变化"><a href="#watch–监听数据变化" class="headerlink" title="watch–监听数据变化"></a>watch–监听数据变化</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;lastname&quot;</span>&gt;</span> +</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;firstname&quot;</span>&gt;</span> =</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;fullname&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">lastname</span>:<span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">firstname</span>:<span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">fullname</span>:<span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>:&#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">watch</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&#x27;lastname&#x27;</span>:<span class="keyword">function</span>(<span class="params">newVal</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">fullname</span>=newVal+<span class="string">&#x27;-&#x27;</span>+<span class="variable language_">this</span>.<span class="property">firstname</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&#x27;firstname&#x27;</span>:<span class="keyword">function</span>(<span class="params">newVal</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">fullname</span>=newVal+<span class="string">&#x27;-&#x27;</span>+<span class="variable language_">this</span>.<span class="property">lastname</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="三个选项"><a href="#三个选项" class="headerlink" title="三个选项"></a>三个选项</h3><ul><li>handler 平时的写法，就默认写的是handler</li><li>immediate<ul><li>默认false，在进入页面，第一次绑定值，不会立刻执行监听，只有数据发生改变才会执行handler中的操作</li><li>为true时，handler在第一次绑定值时就触发</li></ul></li><li>deep 用来进行深度监听，监听到对象属性的变化</li></ul><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.监听基本数据类型</span></span><br><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line">    <span class="title function_">name</span>(<span class="params">val,oldVal</span>) &#123; </span><br><span class="line">        <span class="comment">// val是新值，oldVal是旧值</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 等价于</span></span><br><span class="line">    <span class="attr">name</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">    <span class="comment">// 不能写箭头函数，因为箭头函数中的this值的是函数定义时所在的对象而不是函数运行时所在的对象</span></span><br><span class="line">    <span class="comment">// name: () =&gt; &#123;&#125; // error xxx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 监听对象</span></span><br><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line">    <span class="attr">obj</span>:&#123;</span><br><span class="line">        <span class="comment">// 深度监听</span></span><br><span class="line">        <span class="attr">deep</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 执行函数</span></span><br><span class="line">        <span class="title function_">handler</span>(<span class="params">val</span>) &#123;&#125;,</span><br><span class="line">        <span class="comment">// 自动执行一次</span></span><br><span class="line">        <span class="attr">immediate</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只监听对象中的某一个属性值</span></span><br><span class="line"><span class="comment">// 点语法只限于对象使用，数组不可以</span></span><br><span class="line">    <span class="string">&#x27;obj.age&#x27;</span>(val,old)&#123;&#125;</span><br><span class="line">    <span class="string">&#x27;obj.age&#x27;</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="watch–监听路由变化"><a href="#watch–监听路由变化" class="headerlink" title="watch–监听路由变化"></a>watch–监听路由变化</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/login&quot;</span>&gt;</span>登陆<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/register&quot;</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">watch</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&#x27;$route.path&#x27;</span>:<span class="keyword">function</span>(<span class="params">val,oldVal</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(newVal===<span class="string">&#x27;/login&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;欢迎进入login&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(newVal===<span class="string">&#x27;/register&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;欢迎进入register&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// router/index.js</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">routes</span>:[</span></span><br><span class="line"><span class="language-javascript">            &#123;<span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,<span class="attr">redirect</span>:<span class="string">&#x27;/login&#x27;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">            &#123;<span class="attr">path</span>:<span class="string">&#x27;login&#x27;</span>,<span class="attr">component</span>:login&#125;,</span></span><br><span class="line"><span class="language-javascript">            &#123;<span class="attr">path</span>:<span class="string">&#x27;register&#x27;</span>,<span class="attr">component</span>:register&#125;</span></span><br><span class="line"><span class="language-javascript">        ]</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h2><ul><li>定义：监听一个值返回一个新值，且新值必须使用才能监听成功</li></ul><h3 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h3><ul><li>由于计算属性需要立即返回新值，因此不能处理异步操作</li><li>计算属性不受数据类型限制，任何数据都可以被监听</li><li>默认计算属性的值是只读的，不可以直接修改</li><li>如果要修改计算属性，则需要使用对象写法</li><li>计算属性可以监听多个值</li><li>有缓存，提高渲染性能</li><li>如果在页面上需要用到 对现有的数据进行加工得到新数据，则是要使用计算属性</li><li>想要给计算属性赋值，则需要使用set方法</li><li>计算属性和data一样，都需要设置return，当没有输出结果时，需要排查是不是return漏掉了</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;lastname&quot;</span>&gt;</span> +</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;firstname&quot;</span>&gt;</span> =</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;fullname&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">lastname</span>:<span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">firstname</span>:<span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">computed</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&#x27;fullname&#x27;</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">lastname</span>+<span class="string">&#x27;-&#x27;</span>+<span class="variable language_">this</span>.<span class="property">firstname</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>[!注意]</p><ol><li>fullname没有在data中定义，在computed定义fullname后直接return出去就好</li><li>计算属性的求值结果，会被缓存起来，方便下次直接使用</li><li>不会因为页面中调用几次函数去执行几次，只会根据函数执行来调用函数(比如页面放入很多插值,例如fullname，在function中console.log(ok),刷新页面时，后台只会出现一个OK和初始就在的OK)</li></ol><h4 id="语法格式-1"><a href="#语法格式-1" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">    <span class="comment">// 基础使用</span></span><br><span class="line">    <span class="title function_">newStr</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">str</span>+<span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 修改写法</span></span><br><span class="line">    <span class="attr">myData</span>:&#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">my</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">my</span> = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="watch-computed-methods-对比"><a href="#watch-computed-methods-对比" class="headerlink" title="watch computed methods 对比"></a>watch computed methods 对比</h2><ul><li>computed属性结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用</li><li>methods 方法表示一个具体的操作，主要书写业务逻辑</li><li>watch一个对象，键时需要观察的表达式，值对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体</li></ul><h2 id="watch-computed-区别"><a href="#watch-computed-区别" class="headerlink" title="watch computed 区别"></a>watch computed 区别</h2><ul><li>watch不支持缓存，computed有缓存</li><li>watch支持异步，computed不支持异步</li><li>watch不需要返回新值，computed需要返回新值</li><li>watch只能监听一个属性，computed能监听多个属性</li><li>watch只能监听基本数据类型和数组的值，computed不受数据类型限制</li></ul><h1 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h1><p>扩展了vue没有的操作dom的指令，比如登录页的用户名输入框自动获取焦点，根据用户权限控制某些元素的是否可见等。</p><h2 id="组件内"><a href="#组件内" class="headerlink" title="组件内"></a>组件内</h2><p>directives</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 声明</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">directives</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">focus</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 绑定的时候初始化</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">bind</span>(<span class="params">el,binding</span>)&#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 元素的父集已经呈现，用于指令的操作</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">inserted</span>(<span class="params">el,binding</span>)&#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 更新：自己更新，不能保证子元素更新完</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">update</span>(<span class="params">el,binding</span>)&#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">             <span class="comment">// 等待当前组件的所有元素全部更新完毕</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">componentUpdate</span>(<span class="params">el,binding</span>)&#123;&#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 指令解绑，当组件被销毁的时候触发</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">unbind</span>(<span class="params">el,binding</span>)&#123;&#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">v-focus</span>=<span class="string">&#x27;show&#x27;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h3><p>directive 每次只能声明一个。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&quot;hidden&quot;</span>,&#123;</span><br><span class="line">    <span class="title function_">inserted</span>(<span class="params">el,binding,vnode</span>)&#123;</span><br><span class="line">        <span class="comment">// binding.value是指令绑定入参</span></span><br><span class="line">        <span class="keyword">if</span>(binding.<span class="property">value</span>)&#123;</span><br><span class="line">            el.<span class="property">style</span>.<span class="property">display</span>=<span class="string">&quot;none&quot;</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            el.<span class="property">style</span>.<span class="property">display</span>=<span class="string">&quot;block&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="根据URL分配到对应的应用程序；作用就是解析URL，调用对应的控制器。简而言之，路由是指把数据从一个地方传送到另一个地方的行为和动作"><a href="#根据URL分配到对应的应用程序；作用就是解析URL，调用对应的控制器。简而言之，路由是指把数据从一个地方传送到另一个地方的行为和动作" class="headerlink" title="根据URL分配到对应的应用程序；作用就是解析URL，调用对应的控制器。简而言之，路由是指把数据从一个地方传送到另一个地方的行为和动作"></a>根据URL分配到对应的应用程序；作用就是解析URL，调用对应的控制器。简而言之，路由是指把数据从一个地方传送到另一个地方的行为和动作</h2><h2 id="vue路由有助于在浏览器的URL或历史记录与Vue组件之间建立链接"><a href="#vue路由有助于在浏览器的URL或历史记录与Vue组件之间建立链接" class="headerlink" title="vue路由有助于在浏览器的URL或历史记录与Vue组件之间建立链接"></a>vue路由有助于在浏览器的URL或历史记录与Vue组件之间建立链接</h2><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用router-link组件来导航 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过传入`to`属性指定链接 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- router-link 默认会被渲染成一个&lt;a&gt;&lt;/a&gt;标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span>&gt;</span>home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/news&quot;</span>&gt;</span>news<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 路由出口 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 路由匹配到的组件渲染在这里 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>[1.定义路由组件]:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">var</span> <span class="title class_">Home</span> = &#123; <span class="attr">template</span>: <span class="string">&#x27;#home&#x27;</span>&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> <span class="title class_">News</span> = &#123; <span class="attr">template</span>: <span class="string">&#x27;#news&#x27;</span>&#125;</span></span><br><span class="line"><span class="language-javascript">   </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对应的模块内容： --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;home&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">h3</span>&gt;</span>组件home<span class="tag">&lt;/<span class="name">h3</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;news&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">h3</span>&gt;</span>组件news<span class="tag">&lt;/<span class="name">h3</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>[2.定义路由]：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router/index.js</span></span><br><span class="line">    <span class="keyword">const</span> routes = [</span><br><span class="line">        &#123;<span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Home</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">path</span>: <span class="string">&#x27;/news&#x27;</span>, <span class="attr">component</span>: <span class="title class_">News</span>&#125;, </span><br><span class="line">        &#123;<span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/home&#x27;</span>&#125;</span><br><span class="line">    ];</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    路由命名：</span></span><br><span class="line"><span class="comment">        有时候通过一个名称来标识一个路由显得更方便一些，特别是链接一个路由，或者是执行一些跳转的时候。你可以在创建 Router 实例的时候，在 routes 配置中给某个路由设置名称。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="attr">routes</span>:[</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>,<span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>,<span class="attr">component</span>: <span class="title class_">User</span></span><br><span class="line">       &#125;</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure><p>[3.创建router实例]：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">    <span class="keyword">const</span> router=<span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">        routes,<span class="comment">//(缩写)相当于 routes: routes</span></span><br><span class="line">        <span class="attr">linkActiveClass</span>: <span class="string">&#x27;active&#x27;</span><span class="comment">// 链接激活时默认使用的css类名，用到linkActiveClass来配置，在路由的构造选项里配置默认类名为active</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>[4.创建和挂载根实例]：<br>记得要通过 router 配置参数注入路由，从而让整个应用都有路由功能</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">        <span class="attr">el</span>:<span class="string">`#my`</span>,【</span><br><span class="line">        router</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置路由导航的两种方式"><a href="#设置路由导航的两种方式" class="headerlink" title="设置路由导航的两种方式"></a>设置路由导航的两种方式</h2><h3 id="声明式"><a href="#声明式" class="headerlink" title="声明式"></a>声明式</h3> <router-link :to="/home"><h3 id="编程式"><a href="#编程式" class="headerlink" title="编程式"></a>编程式</h3><p>router.push(‘&#x2F;home’)</p><h3 id="声明式的常见方式"><a href="#声明式的常见方式" class="headerlink" title="声明式的常见方式"></a>声明式的常见方式</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;/home&quot;</span>&gt;</span>home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;path:&#x27;/home&#x27;&#125;&quot;</span>&gt;</span>home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 路由通过名称 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;homename&#x27;&#125;&quot;</span>&gt;</span>home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 直接路由带查询 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 参数query，地址栏变成/home?id=10 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">    path:&#x27;/home&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">    query:&#123;id:10&#125;</span></span></span><br><span class="line"><span class="string"><span class="tag">    &#125;&quot;</span>&gt;</span></span><br><span class="line">    home</span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 命名路由带参查询query，地址栏变成/home?id=10 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">    name:&#x27;homename&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">    query:&#123;id:10&#125;</span></span></span><br><span class="line"><span class="string"><span class="tag">    &#125;&quot;</span>&gt;</span></span><br><span class="line">    home</span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编程式常见方法"><a href="#编程式常见方法" class="headerlink" title="编程式常见方法"></a>编程式常见方法</h3><ul><li>字符串 router.push(‘&#x2F;home’)</li><li>对象 router.push({path:’&#x2F;home’})</li><li>路由通过名称 router.push({name:’homename’})</li><li>直接路由带查询参数query,地址栏变成&#x2F;home?id&#x3D;10</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">push</span>(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">        <span class="attr">query</span>:&#123;<span class="attr">id</span>:<span class="number">10</span>&#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><ul><li>命名路由带查询query，地址栏变成&#x2F;home?id&#x3D;10</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">push</span>(</span><br><span class="line">    &#123;<span class="attr">name</span>:<span class="string">&#x27;homename&#x27;</span>,</span><br><span class="line">    <span class="attr">query</span>:&#123;<span class="attr">id</span>:<span class="number">10</span>&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><h3 id="传入参数的方式"><a href="#传入参数的方式" class="headerlink" title="传入参数的方式"></a>传入参数的方式</h3><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>例：<a href="http://localhost:8080/user/10">http://localhost:8080/user/10</a><br><router-link :to="'/user/'+id">user</router-link></p><ul><li>路由配置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes=[</span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Home</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">&#x27;/news&#x27;</span>, <span class="attr">component</span>: <span class="title class_">News</span>&#125;, </span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>, <span class="attr">component</span>: <span class="title class_">User</span>&#125;, </span><br><span class="line">    <span class="comment">//路由中定义http://localhost:8080/#/user/10 需要定义ID</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>例：<a href="http://localhost:8080/home?id=10">http://localhost:8080/home?id=10</a><br>传入参数的方式：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">    path:&#x27;/home&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">    query: &#123;id: id&#125;</span></span></span><br><span class="line"><span class="string"><span class="tag">&#125;&quot;</span>&gt;</span></span><br><span class="line">test</span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>路由中定义：user?id&#x3D;10 不需要在路由配置中定义参数</p><h3 id="常见路由对象"><a href="#常见路由对象" class="headerlink" title="常见路由对象"></a>常见路由对象</h3><p>在使用vue-router的应用中，路由对象会被注入每个组件中，赋值为this.$route，并且当路由切换时，路由对象会被更新，路由对象暴露了以下属性</p><p>监听单个对象,默认开启深度监听</p>]]></content>
      
      
      <categories>
          
          <category> Vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/03/17/hello-world/"/>
      <url>/2021/03/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
